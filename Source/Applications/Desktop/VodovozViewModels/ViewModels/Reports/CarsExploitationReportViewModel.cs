using ClosedXML.Report;
using Gamma.Utilities;
using NHibernate;
using NHibernate.Criterion;
using NHibernate.Linq;
using NHibernate.Transform;
using QS.Dialog;
using QS.DomainModel.UoW;
using QS.Navigation;
using QS.Project.Journal.EntitySelector;
using QS.ViewModels;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Autofac;
using Vodovoz.Domain.Employees;
using Vodovoz.Domain.Logistic;
using Vodovoz.Domain.Logistic.Cars;
using Vodovoz.Domain.Orders;
using Vodovoz.Services;
using Vodovoz.ViewModels.Dialogs.Logistic;
using Vodovoz.ViewModels.TempAdapters;
using Order = Vodovoz.Domain.Orders.Order;

namespace Vodovoz.ViewModels.Reports
{
	public class CarsExploitationReportViewModel : DialogTabViewModelBase
	{	
		private IInteractiveMessage _interactiveMessage;
		private readonly IRouteListParametersProvider _routeListParametersProvider;
		private readonly ILifetimeScope _scope;
		private readonly int _suburbWageDistrictId;
		private readonly string _templatePath = @".\Reports\Logistic\CarsExploitationReport.xlsx";
		private readonly string _templateWithConditionalFormattingPath =
			@".\Reports\Logistic\CarsExploitationReport-ConditionalFormatting.xlsx";

		private int _startMonth;
		private int _startYear;

		private bool _isConditionalFormattingRequired;
		private CarsExploitationReport _report;

		private bool _canSave;
		private bool _isSaving;
		private bool _canCancelGenerate;
		private bool _isGenerating;
		private IList<Indicator> _selectedIndicators;

		public CarsExploitationReportViewModel(
			IUnitOfWorkFactory unitOfWorkFactory,
			IInteractiveService interactiveService,
			INavigationManager navigation,
			IWageParametersProvider wageParametersProvider,
			IRouteListParametersProvider routeListParametersProvider,
			ICarJournalFactory carJournalFactory,
			ILifetimeScope scope)
			: base(unitOfWorkFactory, interactiveService, navigation)
		{
			Title = "Аналитика эксплуатации ТС";

			_routeListParametersProvider = routeListParametersProvider ?? throw new ArgumentNullException(nameof(routeListParametersProvider)); ;
			_scope = scope ?? throw new ArgumentNullException(nameof(scope));
			_suburbWageDistrictId = (wageParametersProvider ?? throw new ArgumentNullException(nameof(wageParametersProvider)))
				.GetSuburbWageDistrictId;

			if(carJournalFactory is null)
			{
				throw new ArgumentNullException(nameof(carJournalFactory));
			}

			CarAutocompleteSelectorFactory = carJournalFactory.CreateCarAutocompleteSelectorFactoryForCarsExploitationReport(scope);

			_canSave = false;
			_isSaving = false;
			_canCancelGenerate = false;
			_isGenerating = false;

			_startMonth = DateTime.Now.Month;
			_startYear = DateTime.Now.Year;
		}

		public CancellationTokenSource ReportGenerationCancelationTokenSource { get; set; }
		public IEntityAutocompleteSelectorFactory CarAutocompleteSelectorFactory { get; set; }

		#region Параметры фильтров

		public DateTime StartDate => new DateTime(StartYear, StartMonth, 1);

		public int StartMonth
		{
			get => _startMonth;
			set => SetField(ref _startMonth, value);
		}

		public int StartYear
		{
			get => _startYear;
			set => SetField(ref _startYear, value);
		}

		public IndicatorsType IndicatorsType { get; set; }
		public CarOwnType CarOwnType { get; set; }
		public CarTypeOfUse? TypeOfUse { get; set; }
		public Car Car { get; set; }
		public bool ShowCarsWithoutData { get; set; }
		
		public IList<Indicator> SelectedIndicators 
		{
			get => _selectedIndicators;
			set
			{
				SetField(ref _selectedIndicators , value);
				OnPropertyChanged(nameof(CanGenerate));
			}
		}

		#endregion

		public CarsExploitationReport Report
		{
			get => _report;
			set
			{
				SetField(ref _report, value);
				CanSave = _report != null;
			}
		}

		public bool CanSave
		{
			get => _canSave;
			set => SetField(ref _canSave, value);
		}

		public bool IsSaving
		{
			get => _isSaving;
			set
			{
				SetField(ref _isSaving, value);
				CanSave = !IsSaving;
			}
		}

		public bool CanGenerate => !IsGenerating && SelectedIndicators != null && SelectedIndicators.Any();

		public bool CanCancelGenerate
		{
			get => _canCancelGenerate;
			set => SetField(ref _canCancelGenerate, value);
		}

		public bool IsGenerating
		{
			get => _isGenerating;
			set
			{
				SetField(ref _isGenerating, value);
				OnPropertyChanged(nameof(CanGenerate));
				CanCancelGenerate = IsGenerating;
			}
		}

		public bool IsConditionalFormattingRequired
		{
			get => _isConditionalFormattingRequired;
			set => SetField(ref _isConditionalFormattingRequired, value);
		}

		public async Task<CarsExploitationReport> ActionGenerateReport(CancellationToken cancellationToken)
		{
			try
			{
				var report = await Generate(StartDate, IndicatorsType, CarOwnType, TypeOfUse, Car, SelectedIndicators, ShowCarsWithoutData, cancellationToken);
				return report;
			}
			finally
			{
				UoW.Session.Clear();
			}
		}

		private async Task<CarsExploitationReport> Generate(
			DateTime startDate,
			IndicatorsType indicatorsType,
			CarOwnType carOwnType,
			CarTypeOfUse? carTypeOfUse,
			Car car,
			IList<Indicator> selectedIndicators,
			bool showCarsWithoutData,
			CancellationToken cancellationToken)
		{
			var endDate = startDate.AddMonths(1);

			var cargoDailyNorms = GetCargoDailyNorms();

			var result = new CarsExploitationReport
			{
				CreationDate = DateTime.Now,
				StartDate = startDate,
				IndicatorsType = indicatorsType,
				CarOwnType = carOwnType,
				CarTypeOfUse = carTypeOfUse,
				Car = car,
				SelectedIndicators = selectedIndicators,
				CargoDailyNorms = cargoDailyNorms
			};

			var routeLists = await GetRouteLists(carTypeOfUse, carOwnType, car, startDate, endDate, cancellationToken);

			cancellationToken.ThrowIfCancellationRequested();

			IList<Car> cars = routeLists.Select(routeList => routeList.Car).Distinct().ToList();
			var ordersIds = routeLists.SelectMany(routeList => routeList.Addresses.Select(address => address.Order.Id)).ToList();

			if(selectedIndicators.Contains(Indicator.WageDistricts)
				|| selectedIndicators.Contains(Indicator.LoadingCubicMeters)
				|| selectedIndicators.Contains(Indicator.LoadingKilograms)
				|| selectedIndicators.Contains(Indicator.CargoDailyNormKilograms)
				|| selectedIndicators.Contains(Indicator.Loading19Litres)
				|| selectedIndicators.Contains(Indicator.LoadingAverage)
				|| selectedIndicators.Contains(Indicator.LateArrivals)
				|| selectedIndicators.Contains(Indicator.Undeliveries))
			{
				await TouchOrders(ordersIds, cancellationToken);
				cancellationToken.ThrowIfCancellationRequested();
			}

			IList<UndeliveredOrder> undeliveredOrders = new List<UndeliveredOrder>();

			if(selectedIndicators.Contains(Indicator.Undeliveries))
			{
				undeliveredOrders = await GetUndeliveriesForOrders(ordersIds, cancellationToken);
				cancellationToken.ThrowIfCancellationRequested();
			}

			IList<CarEvent> carEvents = new List<CarEvent>();

			if(selectedIndicators.Contains(Indicator.CarEvents))
			{
				carEvents = await GetCarEvents(carTypeOfUse, carOwnType, car, startDate, endDate, cancellationToken);

				if(!selectedIndicators.Contains(Indicator.Trips))
				{
					cars = cars.Concat(carEvents.Select(carEvent => carEvent.Car)).Distinct().ToList();
				}
			}

			if(showCarsWithoutData)
			{
				Car carAlias = null;
				Employee assignedDriverAlias = null;
				CarModel carModelAlias = null;
				CarVersion carVersionAlias = null;

				var carsQuery = UoW.Session.QueryOver(() => carAlias)
					.Inner.JoinAlias(() => carAlias.CarModel, () => carModelAlias)
					.Left.JoinAlias(() => carAlias.Driver, () => assignedDriverAlias)
					.JoinEntityAlias(() => carVersionAlias,
						() => carVersionAlias.Car.Id == carAlias.Id
						      && carVersionAlias.StartDate <= endDate
						      && (carVersionAlias.EndDate == null || carVersionAlias.EndDate >= StartDate))
					.Where(() => !carAlias.IsArchive)
					.And(() => assignedDriverAlias.Id == null || !assignedDriverAlias.VisitingMaster)
					.And(() => carModelAlias.CarTypeOfUse != CarTypeOfUse.Truck)
					.And(() => carVersionAlias.CarOwnType == carOwnType);

				if(carTypeOfUse != null)
				{
					carsQuery.Where(() => carModelAlias.CarTypeOfUse == carTypeOfUse);
				}
				if(car != null)
				{
					carsQuery.Where(() => carAlias.Id == car.Id);
				}

				carsQuery.Fetch(SelectMode.Fetch, x => x.GeographicGroups);
				cars = carsQuery.List();
			}

			cars = cars.OrderBy(c => c.CarModel.CarTypeOfUse)
				.ThenBy(c => c.Id)
				.ToList();

			cancellationToken.ThrowIfCancellationRequested();

			result.Rows = await GenerateRows(cars, selectedIndicators, indicatorsType, routeLists, carEvents, undeliveredOrders, startDate,
				carOwnType, showCarsWithoutData, cargoDailyNorms, cancellationToken);

			FillRowsDaysTotal(result.Rows, StartDate);

			return result;
		}

		private List<CargoDailyNormNode> GetCargoDailyNorms()
		{
			var carTypeOfUses = Enum.GetValues(typeof(CarTypeOfUse)).Cast<CarTypeOfUse>();

			List<CargoDailyNormNode> cargoDailyNorms = new List<CargoDailyNormNode>();

			foreach(var carTypeOfUse in carTypeOfUses)
			{
				cargoDailyNorms.Add(new CargoDailyNormNode
				{
					CarTypeOfUse = carTypeOfUse,
					Amount = _routeListParametersProvider.GetCargoDailyNorm(carTypeOfUse)
				});
			}

			return cargoDailyNorms;
		}

		private async Task<IList<CarsExploitationReportRow>> GenerateRows(
			IList<Car> cars,
			IList<Indicator> selectedIndicators,
			IndicatorsType indicatorsType,
			IList<RouteList> routeLists,
			IList<CarEvent> carEvents,
			IList<UndeliveredOrder> undeliveredOrders,
			DateTime startDate,
			CarOwnType carOwnType,
			bool showCarsWithoutData,
			IList<CargoDailyNormNode> cargoDailyNorms,
			CancellationToken cancellationToken)
		{
			var daysInMonth = DateTime.DaysInMonth(startDate.Year, startDate.Month);

			var rows = new List<CarsExploitationReportRow>();

			foreach(var carItem in cars)
			{
				string carGeoGroups = string.Join(", ", carItem.GeographicGroups.Select(x => x.Name));
				string carDriverFormattedName = GetDriverFormattedName(carItem.Driver);

				if(selectedIndicators.Contains(Indicator.Trips))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.Trips, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessTripsDays(daysInMonth, routeLists, carItem, startDate, indicatorsType);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.CarEvents))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.CarEvents, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessCarEventsDays(daysInMonth, carEvents, carItem, startDate);

					if(showCarsWithoutData || newRow.Days.Any(day => !string.IsNullOrEmpty(day as string)))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.WageDistricts))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.WageDistricts, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessWageDistrictsDays(daysInMonth, routeLists, carItem, startDate, indicatorsType);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.Odometer))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.Odometer, carOwnType, carGeoGroups, carDriverFormattedName);

					newRow.Days = await ProcessOdometerDays(daysInMonth, carItem, startDate);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.MileagePlan))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.MileagePlan, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessMileagePlanDays(daysInMonth, routeLists, carItem, startDate);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.MileageRecalculated))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.MileageRecalculated, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessMileageRecalculatedDays(daysInMonth, routeLists, carItem, startDate);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.MileageConfirmed))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.MileageConfirmed, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessMileageConfirmedDays(daysInMonth, routeLists, carItem, startDate);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.FuelOverspending))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.FuelOverspending, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessFuelOverspendingDays(daysInMonth, routeLists, carItem, startDate);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.Undeliveries))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.Undeliveries, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessUndeliveriesDays(daysInMonth, routeLists, undeliveredOrders, carItem, startDate);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.LateArrivals))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.LateArrivals, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessLateArrivalsDays(daysInMonth, routeLists, carItem, startDate);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				// Indicator.WorkSchedules - не используется

				if(selectedIndicators.Contains(Indicator.Districts))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.Districts, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessDistrictsDays(daysInMonth, routeLists, carItem, startDate, indicatorsType);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.Addresses))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.Addresses, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessAddressesDays(daysInMonth, routeLists, carItem, startDate, indicatorsType);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.Forwarders))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.Forwarders, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessForwardersDays(daysInMonth, routeLists, carItem, startDate, indicatorsType);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.LoadingAverage))
				{
					var newRow = CreateCarExploitationReportRow(carItem, Indicator.LoadingAverage, carOwnType, carGeoGroups,
						carDriverFormattedName);

					newRow.Days = await ProcessLoadingAverageDays(daysInMonth, routeLists, carItem, startDate, indicatorsType);

					if(showCarsWithoutData || newRow.Days.Any(day => day != null))
					{
						rows.Add(newRow);
						newRow.RowNumber = rows.Count;
					}
				}

				if(selectedIndicators.Contains(Indicator.Loading19Litres))
				{
					if(carItem.MaxBottles > 0)
					{
						var newRow = CreateCarExploitationReportRow(carItem, Indicator.Loading19Litres, carOwnType, carGeoGroups,
							carDriverFormattedName);

						newRow.Days = await ProcessLoading19LitresDays(daysInMonth, routeLists, carItem, startDate, indicatorsType);

						if(showCarsWithoutData || newRow.Days.Any(day => day != null))
						{
							rows.Add(newRow);
							newRow.RowNumber = rows.Count;
						}
					}
				}

				if(selectedIndicators.Contains(Indicator.LoadingKilograms))
				{
					if(carItem.CarModel.MaxWeight > 0)
					{
						var newRow = CreateCarExploitationReportRow(carItem, Indicator.LoadingKilograms, carOwnType, carGeoGroups,
							carDriverFormattedName);

						newRow.Days = await ProcessLoadingKilogramsDays(daysInMonth, routeLists, carItem, startDate, indicatorsType);

						if(showCarsWithoutData || newRow.Days.Any(day => day != null))
						{
							rows.Add(newRow);
							newRow.RowNumber = rows.Count;
						}
					}
				}

				if(selectedIndicators.Contains(Indicator.CargoDailyNormKilograms))
				{
					if(carItem.CarModel.MaxWeight > 0)
					{
						var newRow = CreateCarExploitationReportRow(carItem, Indicator.CargoDailyNormKilograms, carOwnType, carGeoGroups,
							carDriverFormattedName);

						newRow.Days = await ProcessCargoDailyNormKilogramsDays(daysInMonth, routeLists, carItem, startDate, indicatorsType, cargoDailyNorms);

						if(showCarsWithoutData || newRow.Days.Any(day => day != null))
						{
							rows.Add(newRow);
							newRow.RowNumber = rows.Count;
						}
					}
				}

				if(selectedIndicators.Contains(Indicator.LoadingCubicMeters))
				{
					if(carItem.CarModel.MaxVolume > 0)
					{
						var newRow = CreateCarExploitationReportRow(carItem, Indicator.LoadingCubicMeters, carOwnType, carGeoGroups,
							carDriverFormattedName);

						newRow.Days = await ProcessLoadingCubicMetersDays(daysInMonth, routeLists, carItem, startDate, indicatorsType);

						if(showCarsWithoutData || newRow.Days.Any(day => day != null))
						{
							rows.Add(newRow);
							newRow.RowNumber = rows.Count;
						}
					}
				}

				cancellationToken.ThrowIfCancellationRequested();
			}

			if(selectedIndicators.Count == 1 
			   && rows.Any()
			   && !new[] { Indicator.CarEvents, Indicator.WageDistricts }.Contains(selectedIndicators.Single()))
			{
				var totalRow = GenerateTotalRow(rows, daysInMonth, selectedIndicators.Single());
				rows.Add(totalRow);
			}

			return rows;
		}

		private CarsExploitationReportRow CreateCarExploitationReportRow(Car car, Indicator indicator, CarOwnType carOwnType,
			string geoGroups, string carDriverFormattedName)
		{
			return new CarsExploitationReportRow
			{
				AssignedDriver = carDriverFormattedName,
				CarOrderNumber = car.OrderNumber ?? 0,
				CarOwnType = carOwnType,
				CarTypeOfUse = car.CarModel.CarTypeOfUse,
				Indicator = indicator,
				RegNumber = car.RegistrationNumber,
				GeographicalGroups = geoGroups,
			};
		}

		private CarsExploitationReportRow GenerateTotalRow(List<CarsExploitationReportRow> rows, int daysInMonth, Indicator indicator)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var totalRowValue = CalculateTotalRowForDay(rows, dayId, indicator);
				if(totalRowValue != null)
				{
					days[dayId] = Math.Round(totalRowValue.Value, 2);
				}
			}

			return new CarsExploitationReportRow
			{
				Indicator = Indicator.TotalRow,
				TotalRowIndicator = indicator,
				Days = days
			};
		}

		private decimal? CalculateTotalRowForDay(List<CarsExploitationReportRow> rows, int dayId, Indicator indicator)
		{
			if(indicator == Indicator.CarEvents || indicator == Indicator.WageDistricts)
			{
				return null;
			}

			if(indicator == Indicator.Trips)
			{
				return rows.Average(row =>
				{
					if(row.Days[dayId] == null)
					{
						return 0;
					}

					decimal.TryParse(row.Days[dayId].ToString(), out var value);

					return value;
				});
			}

			if(new[] { Indicator.LoadingAverage, Indicator.Loading19Litres, Indicator.LoadingKilograms, Indicator.CargoDailyNormKilograms, Indicator.LoadingCubicMeters }
			   .Contains(indicator))
			{
				var workRows = rows.Where(row => row.Days[dayId] != null);

				return workRows.Average(row =>
				{
					if(row.Days[dayId] == null)
					{
						return null;
					}

					decimal.TryParse(row.Days[dayId].ToString(), out var value);

					return value;
				});
			}

			if(indicator == Indicator.Odometer)
			{
				return rows.Sum(row =>
				{
					if(row.Days[dayId] == null)
					{
						return 0;
					}

					var odometer = row.Days[dayId].ToString();
					var index = odometer.IndexOf("/\n");
					decimal.TryParse(odometer.Substring(index + 2, odometer.Length - index - 2), out var value);
					return value;
				});
			}

			return rows.Sum(row =>
			{
				decimal.TryParse(row.Days[dayId]?.ToString(), out var value);
				return value;
			});
		}

		private void FillRowsDaysTotal(IList<CarsExploitationReportRow> rows, DateTime startDate)
		{
			foreach(var row in rows)
			{
				row.DaysTotal = CalculateDaysTotalForRow(row, startDate);
			}
		}

		private decimal? CalculateDaysTotalForRow(CarsExploitationReportRow row, DateTime startDate)
		{
			decimal? total;

			if(new[] { Indicator.CarEvents, Indicator.WageDistricts }.Contains(row.Indicator))
			{
				return null;
			}

			var isTotalRowAverageAllDays = row.Indicator == Indicator.TotalRow
										   && row.TotalRowIndicator == Indicator.Trips;

			if(row.Indicator == Indicator.Trips || isTotalRowAverageAllDays)
			{
				List<object> curDays = null;
				if(DateTime.Today.Month == startDate.Month && DateTime.Today.Year == startDate.Year)
				{
					curDays = row.Days.Take(DateTime.Today.Day).ToList();
				}
				else
				{
					curDays = row.Days.ToList();
				}

				total = curDays.Average(day =>
				{
					decimal.TryParse(day?.ToString(), out var value);
					return value;
				});

				return Math.Round(total.Value, 2);
			}

			var isTotalRowAverageWorkDays = row.Indicator == Indicator.TotalRow
											&& row.TotalRowIndicator.HasValue
											&& new[] { Indicator.LoadingAverage, Indicator.Loading19Litres, Indicator.LoadingKilograms, Indicator.CargoDailyNormKilograms, Indicator.LoadingCubicMeters }
												.Contains(row.TotalRowIndicator.Value);

			if(new[] { Indicator.LoadingAverage, Indicator.Loading19Litres, Indicator.LoadingKilograms, Indicator.CargoDailyNormKilograms, Indicator.LoadingCubicMeters }.Contains(row.Indicator)
			   || isTotalRowAverageWorkDays)
			{
				var workDays = row.Days.Where(day => day != null);

				total = workDays.Average(day =>
				{
					decimal.TryParse(day?.ToString(), out var value);
					return value;
				});

				return Math.Round(total.Value, 2);
			}

			if(new[] { Indicator.Odometer }.Contains(row.Indicator))
			{
				total = row.Days.Sum(day =>
				{
					if(day == null)
					{
						return 0;
					}

					var odometer = day.ToString();
					var index = odometer.IndexOf("/\n");
					decimal.TryParse(odometer.Substring(index + 2, odometer.Length - index - 2), out var value);
					return value;
				});

				return Math.Round(total.Value, 2);
			}

			total = row.Days.Sum(day =>
			{
				decimal.TryParse(day?.ToString(), out var value);
				return value;
			});

			return Math.Round(total.Value, 2);
		}

		private async Task<object[]> ProcessLoadingCubicMetersDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate, IndicatorsType indicatorsType)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProceed = routeLists
					.Where(routeList =>
						routeList.Car.Id == carItem.Id
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& routeList.Addresses.Any(routeListAddress =>
							(indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
							|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed)))
					.ToList();

				var loadingCubicMetersValue =
					CalculateVolumeValue(routeListsToProceed, indicatorsType, Convert.ToDecimal(carItem.CarModel.MaxVolume));

				if(loadingCubicMetersValue > 0)
				{
					days[dayId] = Math.Round(loadingCubicMetersValue, 2);
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessLoadingKilogramsDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate, IndicatorsType indicatorsType)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProceed = routeLists
					.Where(routeList =>
						routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& routeList.Addresses.Any(routeListAddress =>
							(indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
							|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed)))
					.ToList();

				var loadingKilogramsValue = CalculateKilogramsValue(routeListsToProceed, indicatorsType, carItem.CarModel.MaxWeight);

				if(loadingKilogramsValue > 0)
				{
					days[dayId] = Math.Round(loadingKilogramsValue, 2);
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessCargoDailyNormKilogramsDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate, IndicatorsType indicatorsType, IList<CargoDailyNormNode> cargoDailyNorms)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProceed = routeLists
					.Where(routeList =>
						routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& routeList.Addresses.Any(routeListAddress =>
							(indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
							|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed)))
					.ToList();

				var cargoDailyNormKilogramsValue = CalculateCargoDailyNormKilogramsValue(routeListsToProceed, indicatorsType, carItem.CarModel.MaxWeight, cargoDailyNorms);

				if(cargoDailyNormKilogramsValue > 0)
				{
					days[dayId] = Math.Round(cargoDailyNormKilogramsValue, 2);
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessLoading19LitresDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate, IndicatorsType indicatorsType)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProceed = routeLists
					.Where(routeList =>
						routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& routeList.Addresses.Any(routeListAddress =>
							(indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
							|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed)))
					.ToList();

				var loading19Value = Calculate19LValue(routeListsToProceed, indicatorsType, carItem.MaxBottles);

				if(loading19Value > 0)
				{
					days[dayId] = Math.Round(loading19Value, 2);
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessLoadingAverageDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate, IndicatorsType indicatorsType)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProceed = routeLists
					.Where(routeList =>
						routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& (routeList.Car.MaxBottles > 0
							|| routeList.Car.CarModel.MaxVolume > 0
							|| routeList.Car.CarModel.MaxWeight > 0)
						&& routeList.Addresses.Any(routeListAddress =>
							(indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
							|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed)))
					.ToList();

				var carTotalLoadingArgument = (carItem.CarModel.MaxWeight > 0 ? 1 : 0)
					+ (carItem.CarModel.MaxVolume > 0 ? 1 : 0)
					+ (carItem.MaxBottles > 0 ? 1 : 0);

				decimal loadingAverageValue = 0m;

				if(routeListsToProceed.Count > 0)
				{
					if(carItem.CarModel.MaxWeight > 0)
					{
						loadingAverageValue += CalculateKilogramsValue(routeListsToProceed, indicatorsType, carItem.CarModel.MaxWeight);
					}

					if(carItem.CarModel.MaxVolume > 0)
					{
						loadingAverageValue += CalculateVolumeValue(routeListsToProceed, indicatorsType,
							Convert.ToDecimal(carItem.CarModel.MaxVolume));
					}

					if(carItem.MaxBottles > 0)
					{
						loadingAverageValue += Calculate19LValue(routeListsToProceed, indicatorsType, carItem.MaxBottles);
					}

					loadingAverageValue = loadingAverageValue / carTotalLoadingArgument;

					if(loadingAverageValue > 0)
					{
						days[dayId] = Math.Round(loadingAverageValue, 2);
					}
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessForwardersDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate, IndicatorsType indicatorsType)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var forwardersCount = routeLists
					.Count(routeList => routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& routeList.Forwarder != null
						&& (indicatorsType == IndicatorsType.Plan
							|| routeList.Addresses.Any(routeListAddress =>
								!RouteListItem.GetNotDeliveredStatuses().Contains(routeListAddress.Status))));

				if(forwardersCount > 0)
				{
					days[dayId] = forwardersCount;
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessAddressesDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate, IndicatorsType indicatorsType)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var addressesCount = routeLists
					.Where(routeList => routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1))
					.SelectMany(routeList =>
						routeList.Addresses)
					.Count(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
						|| (indicatorsType == IndicatorsType.Fact &&
							!RouteListItem.GetNotDeliveredStatuses().Contains(routeListAddress.Status)));

				if(addressesCount > 0)
				{
					days[dayId] = addressesCount;
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessDistrictsDays(
			int daysInMonth,
			IList<RouteList> routeLists,
			Car carItem,
			DateTime startDate,
			IndicatorsType indicatorsType)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var districtsCount = routeLists
					.Where(routeList => routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1))
					.SelectMany(routeList =>
						routeList.Addresses)
					.Count(routeListAddress => ((indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
							|| (indicatorsType == IndicatorsType.Fact &&
								!RouteListItem.GetNotDeliveredStatuses().Contains(routeListAddress.Status)))
						&& (routeListAddress.RouteList.Driver == null
							|| !routeListAddress.RouteList.Driver.DriverDistrictPrioritySets.Any(ddps =>
								ddps.DateActivated <= routeListAddress.RouteList.Date
								&& (ddps.DateDeactivated == null || ddps.DateDeactivated >= routeListAddress.RouteList.Date)
								&& ddps.DriverDistrictPriorities.Any(ddp =>
									ddp.District.Id == routeListAddress.Order.DeliveryPoint.District?.Id))));

				if(districtsCount > 0)
				{
					days[dayId] = districtsCount;
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessLateArrivalsDays(int daysInMonth, IList<RouteList> routeLists, Car carItem, DateTime startDate)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var lateArrivalsCount = routeLists
					.Where(routeList => routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& routeList.Addresses.Any(routeListAddress => routeListAddress.Status == RouteListItemStatus.Completed))
					.SelectMany(routeList => routeList.Addresses)
					.Count(routeListAddress => routeListAddress.Status == RouteListItemStatus.Completed
						&& routeListAddress.StatusLastUpdate.HasValue
						&& routeListAddress.StatusLastUpdate.Value.TimeOfDay > routeListAddress.Order.DeliverySchedule.To);

				if(lateArrivalsCount > 0)
				{
					days[dayId] = lateArrivalsCount;
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessUndeliveriesDays(int daysInMonth, IList<RouteList> routeLists,
			IList<UndeliveredOrder> undeliveredOrders, Car carItem, DateTime startDate)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var undeliveriedAddressesOrdersIds = routeLists
					.Where(routeList => routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1))
					.SelectMany(routeList => routeList.Addresses)
					.Where(routeListAddress => RouteListItem.GetUndeliveryStatuses().Contains(routeListAddress.Status))
					.Select(routeListAddress => routeListAddress.Order.Id).ToList();

				if(undeliveriedAddressesOrdersIds.Any())
				{
					var undeliveredOrdersCount = undeliveredOrders.Count(undeliveredOrder =>
						undeliveriedAddressesOrdersIds.Contains(undeliveredOrder.OldOrder.Id));

					if(undeliveredOrdersCount > 0)
					{
						days[dayId] = undeliveredOrdersCount;
					}
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessFuelOverspendingDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProcess = routeLists
					.Where(routeList => routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& ((routeList.RecalculatedDistance != null && routeList.RecalculatedDistance.Value > 0)
							|| routeList.ConfirmedDistance > 0))
					.ToList();

				if(routeListsToProcess.Any())
				{
					var difference = routeListsToProcess
						.Sum(routeList => routeList.RecalculatedDistance != null
							? routeList.ConfirmedDistance - routeList.RecalculatedDistance.Value
							: routeList.ConfirmedDistance);

					if(difference > 0)
					{
						days[dayId] = Math.Round(difference, 2);
					}
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessMileageConfirmedDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var confirmedDistance = routeLists
					.Where(routeList => routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& routeList.ConfirmedDistance > 0)
					.Sum(routeList => routeList.ConfirmedDistance);

				if(confirmedDistance > 0)
				{
					days[dayId] = Math.Round(confirmedDistance, 2);
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessMileageRecalculatedDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var recalculatedDistance = routeLists
					.Where(routeList => routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& routeList.RecalculatedDistance != null && routeList.RecalculatedDistance.Value > 0)
					.Sum(routeList => routeList.RecalculatedDistance.Value);

				if(recalculatedDistance > 0)
				{
					days[dayId] = Math.Round(recalculatedDistance, 2);
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessMileagePlanDays(int daysInMonth, IList<RouteList> routeLists, Car carItem,
			DateTime startDate)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var plannedDistance = routeLists
					.Where(routeList => routeList.Car == carItem
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& routeList.PlanedDistance != null && routeList.PlanedDistance.Value > 0)
					.Sum(routeList => routeList.PlanedDistance.Value);

				if(plannedDistance > 0)
				{
					days[dayId] = Math.Round(plannedDistance, 2);
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessWageDistrictsDays(
			int daysInMonth,
			IList<RouteList> routeLists,
			Car car,
			DateTime startDate,
			IndicatorsType indicatorsType)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProceed = routeLists.Where(routeList =>
						routeList.Car == car
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& routeList.Addresses.Any(routeListAddress =>
							(indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
							|| (indicatorsType == IndicatorsType.Fact &&
								!RouteListItem.GetNotDeliveredStatuses().Contains(routeListAddress.Status))))
					.ToList();

				string districtsWageValue = "";

				if(routeListsToProceed.Any())
				{
					var matchedWageDistrictsCount =
						routeListsToProceed.SelectMany(routeList => routeList.Addresses)
							.Where(routeListAddress =>
								(indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
								|| (indicatorsType == IndicatorsType.Fact &&
									!RouteListItem.GetNotDeliveredStatuses().Contains(routeListAddress.Status)))
							.Select(routeListAddress => routeListAddress.Order.DeliveryPoint)
							.Where(deliveryPoint => deliveryPoint.District != null)
							.Select(deliveryPoint => deliveryPoint.District.WageDistrict.Id)
							.Count(wageDistrictId => wageDistrictId == _suburbWageDistrictId);

					districtsWageValue = matchedWageDistrictsCount > 0 ? "П" : "Г";
				}

				if(!string.IsNullOrEmpty(districtsWageValue))
				{
					days[dayId] = districtsWageValue;
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessOdometerDays(int daysInMonth, Car carItem, DateTime startDate)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var currentOdometerReading = carItem.OdometerReadings.SingleOrDefault(o => o.StartDate == startDate.AddDays(dayId));

				if(currentOdometerReading == null)
				{
					continue;
				}

				days[dayId] = currentOdometerReading.Odometer.ToString();

				var previousOdometerReading = carItem.OdometerReadings.OrderByDescending(o => o.StartDate).FirstOrDefault(o => o.StartDate < currentOdometerReading.StartDate);

				if(previousOdometerReading == null)
				{
					days[dayId] += "/\n---";
				}
				else
				{
					var confirmedDistance = UoW.Session.QueryOver<RouteList>()
						.Where(routeList => routeList.Car == carItem 
									&& routeList.Date >= previousOdometerReading.StartDate
									&& routeList.Date < currentOdometerReading.StartDate
									&& routeList.ConfirmedDistance > 0)
						.Select(Projections.Sum<RouteList>(routeList => routeList.ConfirmedDistance))
						.SingleOrDefault<decimal>();

					days[dayId] += $"/\n{currentOdometerReading.Odometer - previousOdometerReading.Odometer - (int)confirmedDistance}";
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessCarEventsDays(
			int daysInMonth,
			IList<CarEvent> carEvents,
			Car car,
			DateTime startDate)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var dayCarEvent = carEvents.Where(carEvent =>
						carEvent.Car.Id == car.Id
						&& carEvent.StartDate <= startDate.AddDays(dayId)
						&& carEvent.EndDate >= startDate.AddDays(dayId))
					.Select(x => x.CarEventType.ShortName)
					.ToList();

				if(dayCarEvent.Any())
				{
					days[dayId] = string.Join(", ", dayCarEvent);
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<object[]> ProcessTripsDays(
			int daysInMonth,
			IList<RouteList> routeListsToProceed,
			Car car,
			DateTime startDate,
			IndicatorsType indicatorsType)
		{
			var days = new object[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var tripsCount = routeListsToProceed
					.Count(routeList => routeList.Car == car
						&& routeList.Date >= startDate.AddDays(dayId)
						&& routeList.Date < startDate.AddDays(dayId + 1)
						&& (indicatorsType == IndicatorsType.Plan
							|| routeList.Addresses.Any(routeListAddress =>
								!RouteListItem.GetNotDeliveredStatuses().Contains(routeListAddress.Status))));

				if(tripsCount > 0)
				{
					days[dayId] = tripsCount;
				}
			}

			return await new ValueTask<object[]>(days);
		}

		private async Task<IList<CarEvent>> GetCarEvents(
			CarTypeOfUse? carTypeOfUse,
			CarOwnType carOwnType,
			Car car,
			DateTime startDate,
			DateTime endDate,
			CancellationToken cancellationToken)
		{
			return await Task.Run(() =>
				{
					CarEvent carEventAlias = null;
					Car carAlias = null;
					CarModel carModelAlias = null;
					CarVersion carVersionAlias = null;
					Employee assignedDriverAlias = null;

					var query = UoW.Session.QueryOver<CarEvent>(() => carEventAlias)
						.Inner.JoinAlias(() => carEventAlias.Car, () => carAlias)
						.Inner.JoinAlias(() => carAlias.CarModel, () => carModelAlias)
						.Left.JoinAlias(() => carAlias.Driver, () => assignedDriverAlias)
						.JoinEntityAlias(() => carVersionAlias,
							() => carVersionAlias.Car.Id == carAlias.Id
								&& carVersionAlias.StartDate <= carEventAlias.StartDate &&
								(carVersionAlias.EndDate == null || carVersionAlias.EndDate >= carEventAlias.StartDate))
						.Where(() => carEventAlias.StartDate <= endDate && carEventAlias.EndDate >= startDate)
						.Where(() => !carAlias.IsArchive)
						.And(() => carModelAlias.CarTypeOfUse != CarTypeOfUse.Truck)
						.And(() => assignedDriverAlias.Id == null || !assignedDriverAlias.VisitingMaster)
						.And(() => carVersionAlias.CarOwnType == carOwnType);

					if(carTypeOfUse != null)
					{
						query.Where(() => carModelAlias.CarTypeOfUse == carTypeOfUse);
					}
					if(car != null)
					{
						query.Where(() => carAlias.Id == car.Id);
					}

					return query
						.TransformUsing(Transformers.DistinctRootEntity)
						.List<CarEvent>();
				},
				cancellationToken);
		}

		private async Task<IList<RouteList>> GetRouteLists(
			CarTypeOfUse? carTypeOfUse,
			CarOwnType carOwnType,
			Car car,
			DateTime startDate,
			DateTime endDate,
			CancellationToken cancellationToken)
		{
			return await Task.Run(() =>
				{
					RouteList routeListAlias = null;
					Car carAlias = null;
					CarModel carModelAlias = null;
					CarVersion carVersionAlias = null;
					Employee assignedDriverAlias = null;

					var query = UoW.Session.QueryOver<RouteList>(() => routeListAlias)
						.Inner.JoinAlias(() => routeListAlias.Car, () => carAlias)
						.Inner.JoinAlias(() => carAlias.CarModel, () => carModelAlias)
						.Left.JoinAlias(() => carAlias.Driver, () => assignedDriverAlias)
						.JoinEntityAlias(() => carVersionAlias,
							() => carVersionAlias.Car.Id == carAlias.Id
								&& carVersionAlias.StartDate <= routeListAlias.Date &&
								(carVersionAlias.EndDate == null || carVersionAlias.EndDate >= routeListAlias.Date))
						.Where(() => routeListAlias.Date >= startDate && routeListAlias.Date < endDate)
						.Where(() => !carAlias.IsArchive)
						.And(() => carModelAlias.CarTypeOfUse != CarTypeOfUse.Truck)
						.And(() => assignedDriverAlias.Id == null || !assignedDriverAlias.VisitingMaster)
						.And(() => carVersionAlias.CarOwnType == carOwnType);

					if(carTypeOfUse != null)
					{
						query.Where(() => carModelAlias.CarTypeOfUse == carTypeOfUse);
					}
					if(car != null)
					{
						query.Where(() => carAlias.Id == car.Id);
					}

					query.Fetch(SelectMode.Fetch, x => x.Addresses)
						.Fetch(SelectMode.Fetch, x => x.Driver)
						.Fetch(SelectMode.Fetch, x => x.Forwarder);

					return query
						.OrderBy(() => carAlias.Id).Asc
						.ThenBy(() => routeListAlias.Id).Asc
						.TransformUsing(Transformers.DistinctRootEntity)
						.List<RouteList>();
				},
				cancellationToken
			);
		}

		private async Task<List<UndeliveredOrder>> GetUndeliveriesForOrders(IList<int> ordersIds, CancellationToken cancellationToken)
		{
			return await Task.Run(() => UoW.Session.Query<UndeliveredOrder>()
					.Where(undeliveredOrder =>
						ordersIds.Contains(undeliveredOrder.OldOrder.Id)
						&& undeliveredOrder.GuiltyInUndelivery.Any(guiltyInUndelivery =>
							guiltyInUndelivery.GuiltySide == GuiltyTypes.Driver
							|| guiltyInUndelivery.GuiltyDepartment.SubdivisionType == SubdivisionType.Logistic))
					.ToList(),
				cancellationToken);
		}

		private async Task TouchOrders(IList<int> ids, CancellationToken cancellationToken)
		{
			await Task.Run(() => UoW.Session.Query<Order>()
					.Where(order => ids.Contains(order.Id))
					.Fetch(order => order.DeliveryPoint)
					.ThenFetch(dp => dp.Category)
					.Fetch(order => order.Client)
					.Fetch(order => order.Contract)
					.FetchMany(order => order.OrderItems)
					.ThenFetch(orderItem => orderItem.Nomenclature)
					.ThenFetch(n => n.Unit)
					.ToList(),
				cancellationToken);
		}

		public void ShowWarning(string message)
		{
			_interactiveMessage.ShowMessage(ImportanceLevel.Warning, message);
		}

		private string GetDriverFormattedName(Employee driver)
		{
			if(driver == null)
			{
				return "-";
			}

			return driver.ShortName;
		}

		private decimal Calculate19LValue(IList<RouteList> routeListsToProceed, IndicatorsType indicatorsType, int carMax19LBottles)
		{
			var routeListsToProceedCount = routeListsToProceed.Count();

			if(routeListsToProceedCount > 0)
			{
				return Math.Round(routeListsToProceed
						.SelectMany(routeList => routeList.Addresses)
						.Where(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
							|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed))
						.Select(routeListAddress => routeListAddress.Order)
						.SelectMany(order => order.OrderItems)
						.Where(orderItem => orderItem.Nomenclature.IsWater19L)
						.Sum(orderItem => indicatorsType == IndicatorsType.Plan ? orderItem.Count : (orderItem.ActualCount ?? 0))
					/ carMax19LBottles * 100 / routeListsToProceedCount
					, 2);
			}
			return 0;
		}

		private decimal CalculateKilogramsValue(IList<RouteList> routeListsToProceed, IndicatorsType indicatorsType, decimal carMaxWeight)
		{
			var routeListsToProceedCount = routeListsToProceed.Count();

			if(routeListsToProceedCount > 0)
			{
				return Math.Round(routeListsToProceed
						.SelectMany(routeList => routeList.Addresses)
						.Where(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
							|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed))
						.Select(routeListAddress => routeListAddress.Order)
						.Sum(order => order.OrderItems.Sum(orderItem =>
								(indicatorsType == IndicatorsType.Plan ? orderItem.Count : (orderItem.ActualCount ?? 0))
								* Convert.ToDecimal(orderItem.Nomenclature.Weight))
							/ carMaxWeight * 100 / routeListsToProceedCount)
					, 2);
			}
			return 0;
		}

		private decimal CalculateCargoDailyNormKilogramsValue(IList<RouteList> routeListsToProceed, IndicatorsType indicatorsType,
			decimal carMaxWeight, IList<CargoDailyNormNode> cargoDailyNorms)
		{
			var routeListsToProceedCount = routeListsToProceed.Count();


			foreach(var rl in routeListsToProceed)
			{
				var v = cargoDailyNorms.SingleOrDefault(x => x.CarTypeOfUse == rl.Car.CarModel.CarTypeOfUse).Amount;
			}

			if(routeListsToProceedCount > 0)
			{
				return Math.Round(routeListsToProceed
						.SelectMany(routeList => routeList.Addresses)
						.Where(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
						                           || (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed))
						.Sum(routeListAddress => routeListAddress.Order.OrderItems.Sum(orderItem =>
								(indicatorsType == IndicatorsType.Plan ? orderItem.Count : (orderItem.ActualCount ?? 0))
								* Convert.ToDecimal(orderItem.Nomenclature.Weight))
							/ (carMaxWeight
							   * cargoDailyNorms.SingleOrDefault(x => x.CarTypeOfUse == routeListAddress.RouteList.Car.CarModel.CarTypeOfUse).Amount)
							   * 100)
					, 2);
			}
			return 0;
		}

		private decimal CalculateVolumeValue(IList<RouteList> routeListsToProceed, IndicatorsType indicatorsType, decimal carMaxVolume)
		{
			var routeListsToProceedCount = routeListsToProceed.Count();

			if(routeListsToProceedCount > 0)
			{
				return Math.Round(routeListsToProceed
						.SelectMany(routeList => routeList.Addresses)
						.Where(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
							|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed))
						.Select(routeListAddress => routeListAddress.Order)
						.Sum(order =>
							order.OrderItems.Sum(orderItem =>
								(indicatorsType == IndicatorsType.Plan ? orderItem.Count : (orderItem.ActualCount ?? 0))
								* Convert.ToDecimal(orderItem.Nomenclature.Volume))
							/ carMaxVolume * 100 / routeListsToProceedCount)
					, 2);
			}

			return 0;
		}

		public void ExportReport(string path)
		{
			string templatePath;

			if(IsConditionalFormattingRequired)
			{
				templatePath = _templateWithConditionalFormattingPath;
			}
			else
			{
				templatePath = _templatePath;
			}

			var template = new XLTemplate(templatePath);

			template.AddVariable(Report);
			template.Generate();

			template.SaveAs(path);
		}

		public void ShowInfoWindow()
		{
			var info =
				"Условные обозначения отчёта: \"К\" - ТС компании, \"В\" - ТС водителя, \"Р\" - ТС в раскате, \"Л\" - Фургон (Ларгус), \"Г\" - Грузовой (Газель).\n" +
				"Пояснение к столбикам: \"П\" - принадлежность. \"Т\" - тип ТС. \"№\" - номер. \"1,2,3\" - даты в месяце.\n" +
				"Выборка в отчёт идёт согласно фильтрам и доп. условиям:\n" +
				" - Не попадают архивные автомобили, фуры, а также автомобили, привязанные к выездным мастерам.\n" +
				"Пояснения к показателям:\n\n" +
				"Условные обозначения: \"Факт\" - фильтр по фактическим данным. \"План\" - фильтр по планируемым данным.\n\n" +

				$"\"{Indicator.Trips.GetEnumTitle()}\": Сумма Кол-ва МЛ.\n" +
				$"Факт: не считает МЛ, у которых все адреса в статусах {RouteListItemStatus.Transfered.GetEnumTitle()}, {RouteListItemStatus.Overdue.GetEnumTitle()} и {RouteListItemStatus.Canceled.GetEnumTitle()}.\n\n" +

				$"\"{Indicator.WageDistricts.GetEnumTitle()}\": Если за день есть хоть один адрес в Пригороде - П, иначе Г.\n" +
				$"Факт: не считаются адреса в статусах {RouteListItemStatus.Transfered.GetEnumTitle()}, {RouteListItemStatus.Overdue.GetEnumTitle()} и {RouteListItemStatus.Canceled.GetEnumTitle()}.\n" +
				"План: не считаются адреса, перенесённые в этот МЛ.\n\n" +

				$"\"{Indicator.MileagePlan.GetEnumTitle()}\": Сумма планируемого расстояния по всем МЛ.\n" +
				"Не отображается для \"В\".\n" +
				"Факт: не отображается.\n\n" +

				$"\"{Indicator.MileageRecalculated.GetEnumTitle()}\": Сумма пересчитанного расстояния по всем МЛ.\n" +
				"Не отображается для \"В\".\n" +
				"План: не отображается.\n\n" +

				$"\"{Indicator.MileageConfirmed.GetEnumTitle()}\": Сумма подтверждённого расстояния по всем МЛ.\n" +
				"Не отображается для \"В\".\n" +
				"План: не отображается.\n\n" +

				$"\"{Indicator.FuelOverspending.GetEnumTitle()}\": Разница подтверждённого и пересчитанного расстояний по всем МЛ.\n" +
				"Не отображается для \"В\".\n" +
				"План: не отображается.\n\n" +

				$"\"{Indicator.Undeliveries.GetEnumTitle()}\": Сумма кол-ва отмен заказов по всем МЛ по вине Подразделений логистики и Водителей.\n" +
				"План: не отображается.\n\n" +

				$"\"{Indicator.LateArrivals.GetEnumTitle()}\": Сумма кол-ва опозданий по всем адресам по всем МЛ.\n" +
				"План: не отображается.\n\n" +

				$"\"{Indicator.Addresses.GetEnumTitle()}\": Сумма кол-ва адресов во всех МЛ.\n" +
				$"Факт: не считаются адреса в статусах {RouteListItemStatus.Transfered.GetEnumTitle()}, {RouteListItemStatus.Overdue.GetEnumTitle()} и {RouteListItemStatus.Canceled.GetEnumTitle()}.\n" +
				"План: не считаются адреса, перенесённые в этот МЛ.\n\n" +

				$"\"{Indicator.Forwarders.GetEnumTitle()}\": Сумма кол-ва МЛ с экспедиторами.\n" +
				"Не отображается для \"К Л\".\n" +
				$"Факт: Не считает МЛ, у которых все адреса в статусах {RouteListItemStatus.Transfered.GetEnumTitle()}, {RouteListItemStatus.Overdue.GetEnumTitle()} и {RouteListItemStatus.Canceled.GetEnumTitle()}.\n\n" +

				$"\"{Indicator.Districts.GetEnumTitle()}\": Сумма кол-ва адресов во всех МЛ, не попадающих в районы, закрепленные за водителем в МЛ.\n" +
				"Версия приоритетов районов водителя подбирается аналогично версии графиков.\n" +
				$"Факт: не считаются адреса в статусах {RouteListItemStatus.Transfered.GetEnumTitle()}, {RouteListItemStatus.Overdue.GetEnumTitle()} и {RouteListItemStatus.Canceled.GetEnumTitle()}.\n" +
				"План: не считаются адреса, перенесённые в этот МЛ.\n\n" +

				$"\"{Indicator.Loading19Litres.GetEnumTitle()}, {Indicator.LoadingKilograms.GetEnumTitle()}, {Indicator.CargoDailyNormKilograms.GetEnumTitle()}, {Indicator.LoadingCubicMeters.GetEnumTitle()}\": Загрузка в процентах.\n" +
				"Факт: считаются только выполненные адреса.\n" +
				"План: не считаются адреса, перенесённые в этот МЛ.\n" +
				$"{Indicator.CargoDailyNormKilograms.GetEnumTitle()} показатель загруженности в %, исходя из нормы (в кг) в день (заполняется в справочнике - кнопка \"Настройка нормы\")\n\n" +

				$"\"{Indicator.LoadingAverage.GetEnumTitle()}\": Cреднее по 19л, кг, м3.\n\n" +

				$"\"{Indicator.Odometer.GetEnumTitle()}\": Расхождение одометра с подтверждённым километражем.\n\n" +

				$"\"{Indicator.TotalRow.GetEnumTitle()}\": Итоговые значения, расчитываются для показателей:\n" +
				"Рейсы: среднее значение из расчета всех календарных дней(эффективность использования авто).\n" +
				"События ТС и Город/ Пригород: расчет не ведется.\n" +
				"Загрузка, 19л, кг, м3: среднее значение из рабочих дней. Исключаем дни без МЛ.\n" +
				"Одометр / Расхождения: сумма расхождений.\n" +
				"Остальные события: сумма значений.\n" +
				$"Для показателя {Indicator.Trips.GetEnumTitle()} в строке Всего отображается среднее значение для всех строк, в том числе учитываются водители без МЛ в этот день.";

			_interactiveMessage.ShowMessage(ImportanceLevel.Info, info, "Информация");
		}

		public void ShowCargoDailyNorms()
		{
			NavigationManager.OpenViewModel<CargoDailyNormViewModel, CarTypeOfUse[]>(this, new CarTypeOfUse[] { CarTypeOfUse.Truck });
		}

		public void SetInteractiveMessageService(IInteractiveMessage interactiveMessage) =>
			_interactiveMessage = interactiveMessage ?? throw new ArgumentNullException(nameof(interactiveMessage));
	}

	public class CarsExploitationReport
	{
		public DateTime CreationDate { get; set; }
		public DateTime StartDate { get; set; }
		public IndicatorsType IndicatorsType { get; set; }
		public CarOwnType CarOwnType { get; set; }
		public CarTypeOfUse? CarTypeOfUse { get; set; }
		public Car Car { get; set; }
		public IList<Indicator> SelectedIndicators { get; set; }
		public string SelectedIndicatorsString => string.Join(", ", SelectedIndicators.Select(x => x.GetEnumTitle()));
		public string Filters => $"Тип индикаторов: {IndicatorsType.GetEnumTitle()}\n" +
			$"Принадлежность автомобиля: {CarOwnType.GetEnumTitle()}\n" +
			$"Тип автомобиля: {CarTypeOfUse?.GetEnumTitle() ?? "-"}\n" +
			$"Автомобиль: {Car?.Title ?? "-"}" +
			$"Выбранные индикаторы: {SelectedIndicatorsString}";
		public IList<CarsExploitationReportRow> Rows { get; set; }
		public string CargoDailyNormsString =>
			$"{string.Join(", ", CargoDailyNorms.Select(x => string.Join(" ", x.CarTypeOfUse.GetEnumTitle(), x.Amount.ToString("F2"), x.Postfix )))}";
		public IList<CargoDailyNormNode> CargoDailyNorms { get; set; } = new List<CargoDailyNormNode>();
		public int [] DaysNumbers => Enumerable.Range(1, DateTime.DaysInMonth(StartDate.Year, StartDate.Month)).ToArray();
	}

	public class CarsExploitationReportRow
	{
		public int? RowNumber { get; set; }
		public int? CarOrderNumber { get; set; }
		public CarOwnType? CarOwnType { get; set; }

		public string CarOwnTypeName
		{
			get
			{
				if(CarOwnType == null)
				{
					return "";
				}

				switch(CarOwnType.Value)
				{
					case Domain.Logistic.Cars.CarOwnType.Company:
						return "K";
					case Domain.Logistic.Cars.CarOwnType.Raskat:
						return "Р";
					case Domain.Logistic.Cars.CarOwnType.Driver:
						return "В";
					default:
						throw new NotSupportedException($"CarOwnType {CarOwnType} is not supported");
				}
			}
		}

		public CarTypeOfUse? CarTypeOfUse { get; set; }

		public string CarTypeOfUseName
		{
			get
			{
				if(CarTypeOfUse == null)
				{
					return "";
				}

				switch(CarTypeOfUse)
				{
					case Domain.Logistic.Cars.CarTypeOfUse.Largus:
						return "Л";
					case Domain.Logistic.Cars.CarTypeOfUse.Truck:
						return "Ф";
					case Domain.Logistic.Cars.CarTypeOfUse.GAZelle:
						return "Г";
					default:
						throw new NotSupportedException($"CarTypeOfUse {CarTypeOfUse} is not supported");
				}
			}
		}

		public string RegNumber { get; set; }
		public Indicator Indicator { get; set; }
		public string IndicatorName => Indicator.GetEnumTitle();
		public string AssignedDriver { get; set; }
		public string GeographicalGroups { get; set; }
		public object[] Days { get; set; }
		public DateTime RowDate { get; set; }
		public Indicator? TotalRowIndicator { get; set; }
		public decimal? DaysTotal { get; set; }
	}

	public enum IndicatorsType
	{
		[Display(Name = "фактическим")]
		Fact,
		[Display(Name = "планируемым")]
		Plan
	}

	public enum Indicator
	{
		[Display(Name = "Рейсы")]
		Trips,
		[Display(Name = "События ТС")]
		CarEvents,
		[Display(Name = "Город/Пригород")]
		WageDistricts,
		[Display(Name = "Км предп")]
		MileagePlan,
		[Display(Name = "Км пересчит")]
		MileageRecalculated,
		[Display(Name = "Км подтв")]
		MileageConfirmed,
		[Display(Name = "Перерасход")]
		FuelOverspending,
		[Display(Name = "Недовозы")]
		Undeliveries,
		[Display(Name = "Опоздания")]
		LateArrivals,
		[Display(Name = "График")]
		WorkSchedules,
		[Display(Name = "Районы")]
		Districts,
		[Display(Name = "Адреса")]
		Addresses,
		[Display(Name = "Экспедиторы")]
		Forwarders,
		[Display(Name = "Загрузка")]
		LoadingAverage,
		[Display(Name = "19л")]
		Loading19Litres,
		[Display(Name = "кг/среднее по рейсам")]
		LoadingKilograms,
		[Display(Name = "кг/норма в день")]
		CargoDailyNormKilograms,
		[Display(Name = "м3")]
		LoadingCubicMeters,
		[Display(Name = "Одометр/Расхождения")]
		Odometer,
		[Display(Name = "Всего")]
		TotalRow
	}
}
