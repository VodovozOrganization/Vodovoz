# Описание механизма построение маршрутов
## Общие сведения
В этом файле находятся общие сведения о механизме и используемых классах. Более детальные описания находятся в комментариях к самим классам.

### Используемые библиотеки
Пожалуй главной библиотекой для оптимизации маршрутов является [Google Optimization Tools (OR-Tools)](https://developers.google.com/optimization/) и (https://github.com/google/or-tools)
Эта библиотека позволяет проводить множество разных оптимизаций в том числе и решение [Vehicle Routing Problem (VRP)](https://en.wikipedia.org/wiki/Vehicle_routing_problem) и ее более сложные варианты такие как Vehicle routing problems with time windows.

_Из-за того что нам нужна 32-х битная библиотека на винде, а разработчики распространяют только 64-битную версию, Библиотеку для виндовс мы собираем сами из исходников._ Инструкция [тут](https://github.com/QualitySolution/Vodovoz/blob/master/lib/Google.OrTools/README.md).

Мы используем реальные расстояния, дорожной сети. Для расчета расстояний используем отдельную службу установленную на сервере OSRM (http://project-osrm.org/), установлена она через Докер инструкция [здесь](https://github.com/QualitySolution/Vodovoz#Запустить-службу-рассчета-расстояний-osrm-на-сервере-можно-следующим-способом)

## Назначение классов и структура механизма

* Vodovoz/Vodovoz/Additions/Logistic/RouteOptimization - Расположение непосредственно самого механизма оптимизации маршрутов
  * RouteOptimizer - Главный класс оптимизатора в нем настраиваются все параметры оптимизации маршрутов в статических полях. В нем существует 2 метода построение оптимальных маршрутов CreateRoutes и RebuidOneRoute. Фактически это единственный класс с которым напрямую должен работать внешний код, остальные классы в этой папке являются вспомогательными или совсем внутренними.
  * CalculatedOrder - Класс для хранения адреса(заказа) с просчитанными на старте оптимизации значениями: количества бутылей заказа, вес и объема заказа.
  * Callback* - Это классы обратных вызовов для расчета величин, различных измерений. Классы с окончаниями AddressCount, Time, Volume, Weight - возвращаю значения соответствующих измерения для каждого адреса. 
  * CallbackDistance - Возвращает расстояние между точками, расстояния возвращаются без учета районов и прочих штрафов. Используется для расчета расстояний при построении одного маршрута. Там штрафы и прочие сложности не нужны.
  * CallbackDistanceDistrict - Возвращает расстоянием между точками, с учетом всевозможных штрафов.
  * CallbackMonitor - Класс мониторинга за работой алгоритма. Возможно не разобрался как правильно его использовать, так как пришлось реализовывать 2 мониторинга. Если разберетесь как более грамотно работать с монитором, перепишите.
  * PossibleTrip - Класс с информацией о поездке(маршруте). Это возможный будущей маршрут, на конкретного водителя и машину. Если машина и водитель едут второй раз, значит будет 2 таких класса, если у водителя 3 ходки, то должно быть создано 3 поездки.
  * ProposedRoute - Класс в котором механизм возвращает результат, то есть это предлагаемый оптимизатором маршрут.
* Vodovoz/VodovozBusiness/Tools/Logistic/ - Механизм расчет расстояний, времени и геометрии маршрута между точками.
  * DistanceCalculator - Простой класс считающий расстояние меду точками напрямую без учета дорожной сети.
  * ExtDistanceCalculator - Класс для массового расчета матрицы расстояний между точками с сохранением рассчитанных расстояний в базе данных в виде кеша. Класс работает с 2-я внешними сервисами Sputnik и OSRM. Загружает расстояния в несколько потоков.
  * RouteGeometryCalculator - Класс тоже служит для получения расстояний, как и предыдущий. Но уже заточен на получения расстояний, времени и геометрии между точками на одном маршруте. Так же сохраняет рассчитанные значения в кеш.
* Vodovoz/VodovozBusiness/Domain/Logistic/CachedDistance.cs - Класс непосредственного сохранения закешированного расстояния в базе данных. Так же содержит кучу статических методов для работы с хешем координат.

## Как работает механизм

Если вы захотите сильно изменять работу механизма настоятельно рекомендую прочитать раздел документации Routing с примерами на Python [отсюда] (https://developers.google.com/optimization/routing). И более подробное описание уже с описанием интерфейса C++ вот [здесь] (https://acrogenesis.com/or-tools/documentation/user_manual/manual/TSP.html). Тут уже имеет смысл даже заглядывать в общие главы и описание вообще расчета ограничений.

Сама библиотека реализует математические модели оптимизации. По сути работает в виде черного ящика. Мы первоначально должны сконфигурировать модель "проблемы". Рассказать библиотеке что мы хотим посчитать в полностью абстрактном виде, в терминах ограничений и стоимостей.

Когда мы запускаем расчет, библиотека используя один из методов построения первого решения указывается в FirstSolutionStrategy. После того как построено первое решение удовлетворяющее ограничениям, запускается механизм оптимизации решения, который что-то меняет в решении опять же в зависимости от настроек и смотрит на результирующее значение стоимости всех маршрутов. Добиваясь наименьшей стоимости.

Значение для оптимизации может быть только одно и это логично, не возможно оптимизировать к 2-м значениям. Если новое измененное решение дает лучший результат, то применяется оно. В нашем случае оптимизируемое значение — это цена(Cost) всех маршрутов.

В качестве базовой размерности стоимость маршрута взяты метры пути. То есть маршрут между 2 точками в 5 км. Будет иметь результирующую стоимость 5000 балов cost. Для учета различных приоритетов и условий на расстояния между точками накладываются дополнительные штрафы в виде балов добавленных к маршруту.

Например, к расстоянию от точки А в точку Б, если точка Б не находится в районе назначенным водителю, добавляется штраф в виде лишних 100 км. То есть навряд ли в обычной ситуации для водителя будет оптимально ехать(как будто на 100км больше) на точки не в своем районе, но если эту точку совсем некому отдать, то водителю придется ехать с увеличенным в виде балов расстоянием. Видов различных штрафов очень много, смотрите код.

Второй важный момент в модели это ограничения, в модели можно создавать измерения под различные ограничения маршрута, например мы создаем измерение количество бутылей в машине. Для каждой машины выставляем свой максимальный объем, этого измерения. Когда маршрут набирает адреса, он с каждого адреса, в измерение добавляет значение с этого адреса. Для измерения можно выставить максимальное значение. Если накопленное вдоль маршрута значение + значение на адресе превысит максимальное для маршрута(машины), то адрес не может быть добавлен в маршрут.

Так же у измерений есть более хитрые параметры, например мягкие значения, то есть мы можем сказать в машине должно быть минимум 20 бутылей. Если бы мы установили полноценное ограничение, то маршрут с 18 бутылями был бы не возможен, библиотека бы посчитала что решение не найдено. Но мы можем задать мягкое ограничение при котором, маршрут с 18 бутылями возможен, но за 2 бутыли ниже минимума, будет добавлен штраф в виде значения умноженного на штраф за одну бутыль.

Максимальные и минимальные значения так же можно устанавливать на конкретные точки маршрута. Например минимальное значение по бутылям у нас стоит на последней точке маршрута, как результат всего маршрута.

Здесь я описал только основы для понимания как это работает. Для более детальной информации смотрите комментарии в класса.

## Общие детали реализации конкретных аспектов

### Реализация достраивания маршрутов
В библиотеке есть механизм позволяющий вносить в нее предварительно построенные маршруты. Но либо я не разобрался как им пользоваться либо он не подходит для наших нужд. Потому как он окончательно фиксирует внесенные в маршрут точки. То есть он позволяет добавить к имеющемуся маршруту адреса, в конец. Но не позволяет поменять порядок уже внесенных, они получаются фиксированные.

Поэтому был придуман следующий подход, мы не передаем в библиотеку заранее построенный маршрут, а просто помечаем все адреса, которые были в маршруте ссылкой на уже имеющийся маршрут. Это позволяет механизму расчета расстояний(стоимости), проверить есть ли этот адрес в маршруте этого водителя. И если адрес предлагается добавить в маршрут к другому водителю то к расстоянию добавляется штраф _RemoveOrderFromExistRLPenalty_, это позволяет построить маршрут для водителя с приоритетом на уже имеющиеся адреса, при этом при жесткой необходимости забрать адрес из предварительно заданного маршрута, и все таки отдать его другому водителю.
