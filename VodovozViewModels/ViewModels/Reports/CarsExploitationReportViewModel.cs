using ClosedXML.Report;
using Gamma.Utilities;
using NHibernate;
using NHibernate.Linq;
using QS.Dialog;
using QS.DomainModel.UoW;
using QS.Navigation;
using QS.Project.Journal.EntitySelector;
using QS.Services;
using QS.ViewModels;
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Vodovoz.CommonEnums;
using Vodovoz.Domain.Employees;
using Vodovoz.Domain.Logistic;
using Vodovoz.Domain.Orders;
using Vodovoz.Services;

namespace Vodovoz.ViewModels.Reports
{
	public class CarsExploitationReportViewModel : DialogTabViewModelBase
	{
		private readonly IInteractiveService _interactiveService;
		private readonly IWageParametersProvider _wageParametersProvider;
		private readonly int _suburbWageDistrictId;
		private readonly string _templatePath = @".\Reports\Logistic\CarsExploitationReport.xlsx";

		private readonly IReadOnlyList<RouteListItemStatus> _notActualRouteListAddressStatuses = new[] { RouteListItemStatus.Transfered, RouteListItemStatus.Canceled, RouteListItemStatus.Overdue }.ToList();
		private readonly IReadOnlyList<RouteListItemStatus> _undeliveriesRouteListAddressesStatuses = new[] { RouteListItemStatus.Canceled, RouteListItemStatus.Overdue }.ToList();

		public CarsExploitationReportViewModel(
			IUnitOfWorkFactory unitOfWorkFactory,
			IInteractiveService interactiveService,
			INavigationManager navigation,
			IWageParametersProvider wageParametersProvider,
			IEntityAutocompleteSelectorFactory entityAutocompleteSelectorFactory)
			: base(unitOfWorkFactory, interactiveService, navigation)
		{
			Title = "Аналитика эксплуатации ТС";

			_interactiveService = interactiveService ?? throw new ArgumentNullException(nameof(interactiveService));
			_wageParametersProvider = wageParametersProvider ?? throw new ArgumentNullException(nameof(wageParametersProvider));
			_suburbWageDistrictId = _wageParametersProvider.GetSuburbWageDistrictId;

			CarAutocompleteSelectorFactory = entityAutocompleteSelectorFactory ?? throw new ArgumentNullException(nameof(entityAutocompleteSelectorFactory));
			DriverCarKinds = UoW.GetAll<DriverCarKind>();
		}

		public CancellationTokenSource ReportGenerationCancelationTokenSource { get; set; }
		public IEntityAutocompleteSelectorFactory CarAutocompleteSelectorFactory { get; set; }

		#region Параметры фильтров

		#region DateSelectorsDataRegion
		public DateTime StartDate => new DateTime(StartYear, StartMonth, 1);

		private int _startMonth = DateTime.Now.Month;
		public int StartMonth
		{
			get => _startMonth;
			set
			{
				SetField(ref _startMonth, value);
			}
		}

		private int _startYear = DateTime.Now.Year;
		public int StartYear
		{
			get => _startYear;
			set
			{
				SetField(ref _startYear, value);
			}
		}
		#endregion
		public IndicatorsType IndicatorsType { get; set; }
		public CarOwnType CarOwnType { get; set; }
		public CompanyCarType CompanyCarType { get; set; }
		public IEnumerable<DriverCarKind> DriverCarKinds { get; set; } = new List<DriverCarKind>();
		public DriverCarKind DriverCarKind { get; set; }
		public AllYesNo Raskat { get; set; }
		public Car Car { get; set; }
		public IEnumerable<Indicator> SelectedIndicators { get; set; }

		#endregion

		private CarsExploitationReport _report;
		public CarsExploitationReport Report
		{
			get => _report;
			set
			{
				SetField(ref _report, value);
				CanSave = _report != null;
			}
		}

		private bool _canSave = false;
		public bool CanSave
		{
			get => _canSave;
			set => SetField(ref _canSave, value);
		}

		private bool _isSaving = false;
		public bool IsSaving
		{
			get => _isSaving;
			set
			{
				SetField(ref _isSaving, value);
				CanSave = !IsSaving;
				OnPropertyChanged(() => SaveButtonLabel);
			}
		}

		private bool _canGenerate = true;
		public bool CanGenerate
		{
			get => _canGenerate;
			set
			{
				SetField(ref _canGenerate, value);
				OnPropertyChanged(() => CanGenerateOrCancel);
			}
		}

		private bool _canCancelGenerate = false;
		public bool CanCancelGenerate
		{
			get => _canCancelGenerate;
			set
			{
				SetField(ref _canCancelGenerate, value);
				OnPropertyChanged(() => CanGenerateOrCancel);
			}
		}

		public bool CanGenerateOrCancel => CanGenerate || CanCancelGenerate;

		private bool _isGenerating = false;
		public bool IsGenerating
		{
			get => _isGenerating;
			set
			{
				SetField(ref _isGenerating, value);
				CanGenerate = !IsGenerating;
				CanCancelGenerate = IsGenerating;
				OnPropertyChanged(() => GenerateButtonLabel);
			}
		}

		public string SaveButtonLabel => IsSaving ? "Отчет сохраняется..." : "Сохранить";

		public string GenerateButtonLabel => IsGenerating? "Отчет в процессе формирования... (Отменить)" : "Сформировать отчет";

		public async Task<CarsExploitationReport> ActionGenerateReport(CancellationToken cancelationToken)
		{
			if(!SelectedIndicators.Any())
			{
				_interactiveService.ShowMessage(ImportanceLevel.Warning, "Не выбрано ни 1 показателя");
				return null;
			}

			try
			{
				var stopwatch = new System.Diagnostics.Stopwatch();
				stopwatch.Start();
				var report = await Generate(StartDate, IndicatorsType, CarOwnType, CompanyCarType, DriverCarKind, Raskat, Car, SelectedIndicators, cancelationToken);
				stopwatch.Stop();
				Console.WriteLine($" Время геренарции отчета: { stopwatch.ElapsedMilliseconds }");
				return report;
			}
			finally
			{
				UoW.Session.Clear();
			}
		}

		private async Task<CarsExploitationReport> Generate(
			DateTime startDate,
			IndicatorsType indicatorsType,
			CarOwnType carOwnType,
			CompanyCarType companyCarType,
			DriverCarKind driverCarKind,
			AllYesNo raskat,
			Car car,
			IEnumerable<Indicator> selectedIndicators,
			CancellationToken cancelationToken)
		{
			var endDate = startDate.AddMonths(1);

			var result = new CarsExploitationReport()
			{
				CreationDate = DateTime.Now,
				StartDate = startDate,
				IndicatorsType = indicatorsType,
				CarOwnType = carOwnType,
				CompanyCarType = companyCarType,
				DriverCarKind = driverCarKind,
				Raskat = raskat,
				Car = car,
				SelectedIndicators = selectedIndicators,
			};

			var rows = new List<CarsExploitationReportRow>();

			var carTypeOfUse = GetCarTypesOfUse(carOwnType, companyCarType);

			var routeLists = await GetRouteLists(carTypeOfUse, car, raskat, driverCarKind, startDate, endDate, cancelationToken);

			cancelationToken.ThrowIfCancellationRequested();

			var cars = routeLists.Select(routeList => routeList.Car).Distinct();

			var ordersIds = routeLists.SelectMany(routeList => routeList.Addresses.Select(address => address.Order.Id));

			if(selectedIndicators.Contains(Indicator.WageDistricts)
			|| selectedIndicators.Contains(Indicator.LoadingCubicMeters)
			|| selectedIndicators.Contains(Indicator.LoadingKilograms)
			|| selectedIndicators.Contains(Indicator.Loading19Litres)
			|| selectedIndicators.Contains(Indicator.LoadingAverage)
			|| selectedIndicators.Contains(Indicator.LateArrivals)
			|| selectedIndicators.Contains(Indicator.Undeliveries))
			{
				await TouchOrders(ordersIds, cancelationToken);
				cancelationToken.ThrowIfCancellationRequested();
			}

			IEnumerable<UndeliveredOrder> undeliveredOrders = new List<UndeliveredOrder>();

			if(selectedIndicators.Contains(Indicator.Undeliveries))
			{
				undeliveredOrders = await GetUndeliveriesForOrders(ordersIds, cancelationToken);
				cancelationToken.ThrowIfCancellationRequested();
			}

			IEnumerable<CarEvent> carEvents = new List<CarEvent>();

			if(selectedIndicators.Contains(Indicator.CarEvents))
			{
				carEvents = await GetCarEvents(carTypeOfUse, car, raskat, driverCarKind, startDate, endDate, cancelationToken);

				cars = cars.Concat(carEvents.Select(carEvent => carEvent.Car))
					.Distinct();
			}

			cancelationToken.ThrowIfCancellationRequested();

			result.Rows = await GenerateRows(cars, selectedIndicators, indicatorsType, routeLists, carEvents, undeliveredOrders, startDate, cancelationToken);

			return result;
		}

		private async Task<IEnumerable<CarsExploitationReportRow>> GenerateRows(
			IEnumerable<Car> cars,
			IEnumerable<Indicator> selectedIndicators,
			IndicatorsType indicatorsType,
			IEnumerable<RouteList> routeLists,
			IEnumerable<CarEvent> carEvents,
			IEnumerable<UndeliveredOrder> undeliveredOrders,
			DateTime startDate,
			CancellationToken cancellationToken)
		{
			var daysInMonth = DateTime.DaysInMonth(startDate.Year, startDate.Month);

			var rows = new List<CarsExploitationReportRow>();

			foreach(var carItem in cars)
			{
				CompanyCarType? rowCompanyCarType = GetCompanyCarType(carItem.TypeOfUse);

				CarOwnType? rowCarOwnType = GetCarOwnType(carItem.TypeOfUse);

				string carGeoGroups = string.Join(", ", carItem.GeographicGroups.Select(x => x.Name));

				string carDriverFornatedName = GetDriverFormatedName(carItem.Driver);

				if(selectedIndicators.Contains(Indicator.Trips))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.Trips,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups,
					};

					newRow.Days = await ProcessTripsDays(daysInMonth, routeLists, carItem, startDate, indicatorsType, cancellationToken);

					rows.Add(newRow);
				}

				if(selectedIndicators.Contains(Indicator.CarEvents))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.CarEvents,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups,
						Days = new string[daysInMonth]
					};

					newRow.Days = await ProcessCarEventsDays(daysInMonth, carEvents, carItem, startDate, cancellationToken);

					if(newRow.Days.Any(day => !string.IsNullOrEmpty(day)))
					{
						rows.Add(newRow);
					}
				}

				if(selectedIndicators.Contains(Indicator.WageDistricts))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.WageDistricts,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups,
					};

					newRow.Days = await ProcessWageDistrictsDays(daysInMonth, routeLists, carItem, startDate, indicatorsType, cancellationToken);

					rows.Add(newRow);
				}

				if(selectedIndicators.Contains(Indicator.MileagePlan))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.MileagePlan,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups,
					};

					newRow.Days = await ProcessMileagePlanDays(daysInMonth, routeLists, carItem, startDate, cancellationToken);

					rows.Add(newRow);
				}

				if(selectedIndicators.Contains(Indicator.MileageRecalculated))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.MileageRecalculated,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups,
					};

					newRow.Days = await ProcessMileageRecalculatedDays(daysInMonth, routeLists, carItem, startDate, cancellationToken);

					rows.Add(newRow);
				}

				if(selectedIndicators.Contains(Indicator.MileageConfirmed))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.MileageConfirmed,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups,
					};

					newRow.Days = await ProcessMileageConfirmedDays(daysInMonth, routeLists, carItem, startDate, cancellationToken);

					rows.Add(newRow);
				}

				if(selectedIndicators.Contains(Indicator.FuelOverspending))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.FuelOverspending,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups
					};

					newRow.Days = await ProcessFuelOverspendingDays(daysInMonth, routeLists, carItem, startDate, cancellationToken);

					rows.Add(newRow);
				}

				if(selectedIndicators.Contains(Indicator.Undeliveries))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.Undeliveries,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups
					};

					newRow.Days = await ProcessUndeliveriesDays(daysInMonth, routeLists, undeliveredOrders, carItem, startDate, cancellationToken);

					if(newRow.Days.Any(day => !string.IsNullOrEmpty(day)))
					{
						rows.Add(newRow);
					}
				}

				if(selectedIndicators.Contains(Indicator.LateArrivals))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.LateArrivals,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups
					};

					newRow.Days = await ProcessLateArrivalsDays(daysInMonth, routeLists, undeliveredOrders, carItem, startDate, cancellationToken);

					if(newRow.Days.Any(day => !string.IsNullOrEmpty(day)))
					{
						rows.Add(newRow);
					}
				}

				// Indicator.WorkSchedules - не используется

				if(selectedIndicators.Contains(Indicator.Districts))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.Districts,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups,
					};

					newRow.Days = await ProcessDistrictsDays(daysInMonth, routeLists, carItem, startDate, indicatorsType , cancellationToken);

					rows.Add(newRow);
				}

				if(selectedIndicators.Contains(Indicator.Addresses))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.Addresses,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups
					};

					newRow.Days = await ProcessAddressesDays(daysInMonth, routeLists, carItem, startDate, indicatorsType, cancellationToken);

					rows.Add(newRow);
				}

				if(selectedIndicators.Contains(Indicator.Forwarders))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.Forwarders,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups
					};

					newRow.Days = await ProcessForwardersDays(daysInMonth, routeLists, carItem, startDate, indicatorsType, cancellationToken);

					if(newRow.Days.Any(day => !string.IsNullOrEmpty(day)))
					{
						rows.Add(newRow);
					}
				}

				if(selectedIndicators.Contains(Indicator.LoadingAverage))
				{
					var newRow = new CarsExploitationReportRow()
					{
						AssignedDriver = carDriverFornatedName,
						CarOrderNumber = carItem.OrderNumber ?? 0,
						CarOwnType = rowCarOwnType,
						CarType = rowCompanyCarType,
						Indicator = Indicator.LoadingAverage,
						RegNumber = carItem.RegistrationNumber,
						GeographicalGroups = carGeoGroups,
					};

					newRow.Days = await ProcessLoadingAverageDays(daysInMonth, routeLists, carItem, startDate, indicatorsType, cancellationToken);

					if(newRow.Days.Any(day => !string.IsNullOrEmpty(day)))
					{
						rows.Add(newRow);
					}
				}

				if(selectedIndicators.Contains(Indicator.Loading19Litres))
				{
					if(carItem.MaxBottles > 0)
					{
						var newRow = new CarsExploitationReportRow()
						{
							AssignedDriver = carDriverFornatedName,
							CarOrderNumber = carItem.OrderNumber ?? 0,
							CarOwnType = rowCarOwnType,
							CarType = rowCompanyCarType,
							Indicator = Indicator.Loading19Litres,
							RegNumber = carItem.RegistrationNumber,
							GeographicalGroups = carGeoGroups,
						};

						newRow.Days = await ProcessLoading19LitresDays(daysInMonth, routeLists, carItem, startDate, indicatorsType, cancellationToken);

						if(newRow.Days.Any(day => !string.IsNullOrEmpty(day)))
						{
							rows.Add(newRow);
						}
					}
				}

				if(selectedIndicators.Contains(Indicator.LoadingKilograms))
				{
					if(carItem.MaxWeight > 0)
					{
						var newRow = new CarsExploitationReportRow()
						{
							AssignedDriver = carDriverFornatedName,
							CarOrderNumber = carItem.OrderNumber ?? 0,
							CarOwnType = rowCarOwnType,
							CarType = rowCompanyCarType,
							Indicator = Indicator.LoadingKilograms,
							RegNumber = carItem.RegistrationNumber,
							GeographicalGroups = carGeoGroups,
						};

						newRow.Days = await ProcessLoadingKilogramsDays(daysInMonth, routeLists, carItem, startDate, indicatorsType, cancellationToken);

						if(newRow.Days.Any(day => !string.IsNullOrEmpty(day)))
						{
							rows.Add(newRow);
						}
					}
				}

				if(selectedIndicators.Contains(Indicator.LoadingCubicMeters))
				{
					if(carItem.MaxVolume > 0)
					{
						var newRow = new CarsExploitationReportRow()
						{
							AssignedDriver = carDriverFornatedName,
							CarOrderNumber = carItem.OrderNumber ?? 0,
							CarOwnType = rowCarOwnType,
							CarType = rowCompanyCarType,
							Indicator = Indicator.LoadingCubicMeters,
							RegNumber = carItem.RegistrationNumber,
							GeographicalGroups = carGeoGroups,
						};

						newRow.Days = await ProcessLoadingCubicMetersDays(daysInMonth, routeLists, carItem, startDate, indicatorsType, cancellationToken);

						if(newRow.Days.Any(day => !string.IsNullOrEmpty(day)))
						{
							rows.Add(newRow);
						}
					}
				}

				cancellationToken.ThrowIfCancellationRequested();
			}
			return rows;
		}

		private async Task<string[]> ProcessLoadingCubicMetersDays(int daysInMonth, IEnumerable<RouteList> routeLists, Car carItem, DateTime startDate, IndicatorsType indicatorsType, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{

				var routeListsToProceed = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& routeList.Addresses.Any(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
																					|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed)));

				var routeListsToProceedCount = routeListsToProceed.Count();

				var loadingCubicMetersValue = CalculateVolumeValue(routeListsToProceed, indicatorsType, Convert.ToDecimal(carItem.MaxVolume));

				if(loadingCubicMetersValue > 0)
				{
					days[dayId] = loadingCubicMetersValue.ToString("F2");
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessLoadingKilogramsDays(int daysInMonth, IEnumerable<RouteList> routeLists, Car carItem, DateTime startDate, IndicatorsType indicatorsType, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProceed = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& routeList.Addresses.Any(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
																					|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed)));

				var loadingKilogramsValue = CalculateKilogramsValue(routeListsToProceed, indicatorsType, carItem.MaxWeight);

				if(loadingKilogramsValue > 0)
				{
					days[dayId] = loadingKilogramsValue.ToString("F2");
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessLoading19LitresDays(int daysInMonth, IEnumerable<RouteList> routeLists, Car carItem, DateTime startDate, IndicatorsType indicatorsType, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProceed = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& routeList.Addresses.Any(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
																					|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed)));

				var loading19Value = Calculate19LValue(routeListsToProceed, indicatorsType, carItem.MaxBottles);

				if(loading19Value > 0)
				{
					days[dayId] = loading19Value.ToString("F2");
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessLoadingAverageDays(int daysInMonth, IEnumerable<RouteList> routeLists, Car carItem, DateTime startDate, IndicatorsType indicatorsType, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProceed = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& (routeList.Car.MaxBottles > 0
											|| routeList.Car.MaxVolume > 0
											|| routeList.Car.MaxWeight > 0)
										&& routeList.Addresses.Any(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
																					|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed)))
					.ToList();

				var carTotalLoadingArgument = (carItem.MaxWeight > 0 ? 1 : 0)
											+ (carItem.MaxVolume > 0 ? 1 : 0)
											+ (carItem.MaxBottles > 0 ? 1 : 0);

				decimal loadingAverageValue = 0m;

				if(routeListsToProceed.Count > 0)
				{
					if(carItem.MaxWeight > 0)
					{
						loadingAverageValue += CalculateKilogramsValue(routeListsToProceed, indicatorsType, carItem.MaxWeight);
					}

					if(carItem.MaxVolume > 0)
					{
						loadingAverageValue += CalculateVolumeValue(routeListsToProceed, indicatorsType, Convert.ToDecimal(carItem.MaxVolume));
					}

					if(carItem.MaxBottles > 0)
					{
						loadingAverageValue += Calculate19LValue(routeListsToProceed, indicatorsType, carItem.MaxBottles);
					}

					loadingAverageValue = loadingAverageValue / carTotalLoadingArgument;

					if(loadingAverageValue > 0)
					{
						days[dayId] = loadingAverageValue.ToString("F2");
					}
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessForwardersDays(int daysInMonth, IEnumerable<RouteList> routeLists, Car carItem, DateTime startDate, IndicatorsType indicatorsType, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var forwardersCount = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& routeList.Forwarder != null
										&& (indicatorsType == IndicatorsType.Plan
										|| routeList.Addresses.Any(routeListAddress => !_notActualRouteListAddressStatuses.Contains(routeListAddress.Status))))
					.Count();
				if(forwardersCount > 0)
				{
					days[dayId] = forwardersCount.ToString();
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessAddressesDays(int daysInMonth, IEnumerable<RouteList> routeLists, Car carItem, DateTime startDate, IndicatorsType indicatorsType, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var addressesCount = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1))
					.SelectMany(routeList => routeList.Addresses)
					.Where(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
												|| (indicatorsType == IndicatorsType.Fact && !_notActualRouteListAddressStatuses.Contains(routeListAddress.Status)))
					.Count();

				if(addressesCount > 0)
				{
					days[dayId] = addressesCount.ToString();
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessDistrictsDays(
			int daysInMonth,
			IEnumerable<RouteList> routeLists,
			Car carItem,
			DateTime startDate,
			IndicatorsType indicatorsType,
			CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var districtsCount = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1))
					.SelectMany(routeList => routeList.Addresses)
					.Where(routeListAddress => ((indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
												|| (indicatorsType == IndicatorsType.Fact && !_notActualRouteListAddressStatuses.Contains(routeListAddress.Status)))
											&& (routeListAddress.RouteList.Driver == null
												|| !routeListAddress.RouteList.Driver.DriverDistrictPrioritySets.Any(ddps =>
															ddps.DateActivated <= routeListAddress.RouteList.Date
														&& (ddps.DateDeactivated == null || ddps.DateDeactivated >= routeListAddress.RouteList.Date)
														&& ddps.DriverDistrictPriorities.Any(ddp =>
																ddp.District.Id == routeListAddress.Order.DeliveryPoint.District?.Id))))
					.Count();

				if(districtsCount > 0)
				{
					days[dayId] = districtsCount.ToString();
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessLateArrivalsDays(int daysInMonth, IEnumerable<RouteList> routeLists, IEnumerable<UndeliveredOrder> undeliveredOrders, Car carItem, DateTime startDate, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var lateArrivalsCount = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& routeList.Addresses.Any(routeListAddress => routeListAddress.Status == RouteListItemStatus.Completed))
					.SelectMany(routeList => routeList.Addresses)
					.Where(routeListAddress => routeListAddress.Status == RouteListItemStatus.Completed
											&& routeListAddress.StatusLastUpdate.HasValue
											&& routeListAddress.StatusLastUpdate.Value.TimeOfDay > routeListAddress.Order.DeliverySchedule.To)
					.Count();

				if(lateArrivalsCount > 0)
				{
					days[dayId] = lateArrivalsCount.ToString();
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessUndeliveriesDays(int daysInMonth, IEnumerable<RouteList> routeLists, IEnumerable<UndeliveredOrder> undeliveredOrders, Car carItem, DateTime startDate, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var undeliveriedAddressesOrdersIds = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1))
					.SelectMany(routeList => routeList.Addresses)
					.Where(routeListAddress => _undeliveriesRouteListAddressesStatuses.Contains(routeListAddress.Status))
					.Select(routeListAddress => routeListAddress.Order.Id).ToList();

				if(undeliveriedAddressesOrdersIds.Any())
				{
					var undeliveredOrdersCount = undeliveredOrders.Count(undeliveredOrder => undeliveriedAddressesOrdersIds.Contains(undeliveredOrder.Id));

					if(undeliveredOrdersCount > 0)
					{
						days[dayId] = undeliveredOrdersCount.ToString("F0");
					}
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessFuelOverspendingDays(int daysInMonth, IEnumerable<RouteList> routeLists, Car carItem, DateTime startDate, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProcess = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& ((routeList.RecalculatedDistance != null && routeList.RecalculatedDistance.Value > 0)
										|| routeList.ConfirmedDistance > 0));

				if(routeListsToProcess.Any())
				{
					var difference = routeListsToProcess
						.Sum(routeList => routeList.RecalculatedDistance != null
										? routeList.ConfirmedDistance - routeList.RecalculatedDistance.Value
										: routeList.ConfirmedDistance);

					if(difference > 0)
					{
						days[dayId] = difference.ToString("F0");
					}
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessMileageConfirmedDays(int daysInMonth, IEnumerable<RouteList> routeLists, Car carItem, DateTime startDate, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var confirmedDistance = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& routeList.ConfirmedDistance > 0)
					.Sum(routeList => routeList.ConfirmedDistance);

				if(confirmedDistance > 0)
				{
					days[dayId] = confirmedDistance.ToString("F0");
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessMileageRecalculatedDays(int daysInMonth, IEnumerable<RouteList> routeLists, Car carItem, DateTime startDate, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var recalculatedDistance = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& routeList.RecalculatedDistance != null && routeList.RecalculatedDistance.Value > 0)
					.Sum(routeList => routeList.RecalculatedDistance.Value);

				if(recalculatedDistance > 0)
				{
					days[dayId] = recalculatedDistance.ToString("F0");
				}
			}
			
			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessMileagePlanDays(int daysInMonth, IEnumerable<RouteList> routeLists, Car carItem, DateTime startDate, CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var plannedDistance = routeLists
					.Where(routeList => routeList.Car == carItem
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& routeList.PlanedDistance != null && routeList.PlanedDistance.Value > 0)
					.Sum(routeList => routeList.PlanedDistance.Value);

				if(plannedDistance > 0)
				{
					days[dayId] = plannedDistance.ToString("F0");
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessWageDistrictsDays(
			int daysInMonth,
			IEnumerable<RouteList> routeLists,
			Car car,
			DateTime startDate,
			IndicatorsType indicatorsType,
			CancellationToken cancellationToken)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var routeListsToProceed = routeLists.Where(routeList => routeList.Car == car
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& routeList.Addresses.Any(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
																					|| (indicatorsType == IndicatorsType.Fact && !_notActualRouteListAddressStatuses.Contains(routeListAddress.Status))));


				string districtsWageValue = "";

				if(routeListsToProceed.Count() > 0)
				{
					var matchedWageDistrictsCount =
						routeListsToProceed.SelectMany(routeList => routeList.Addresses)
						.Where(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
												|| (indicatorsType == IndicatorsType.Fact && !_notActualRouteListAddressStatuses.Contains(routeListAddress.Status)))
						.Select(routeListAddress => routeListAddress.Order.DeliveryPoint)
						.Where(deliveryPoint => deliveryPoint.District != null)
						.Select(deliveryPoint => deliveryPoint.District.WageDistrict.Id)
						.Count(wageDistrictId => wageDistrictId == _suburbWageDistrictId);

					districtsWageValue = matchedWageDistrictsCount > 0 ? "П" : "Г";
				}

				if(!string.IsNullOrEmpty(districtsWageValue))
				{
					days[dayId] = districtsWageValue;
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessCarEventsDays(
			int daysInMonth,
			IEnumerable<CarEvent> carEvents,
			Car car,
			DateTime startDate,
			CancellationToken cancellationToken
			)
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var dayCarEvent = carEvents.Where(carEvent => carEvent.Car == car
															&& carEvent.StartDate <= startDate.AddDays(dayId)
															&& carEvent.EndDate >= startDate.AddDays(dayId))
											.Select(x => x.CarEventType.ShortName);

				if(dayCarEvent.Count() > 0)
				{
					days[dayId] = string.Join(", ", dayCarEvent);
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<string[]> ProcessTripsDays(
			int daysInMonth,
			IEnumerable<RouteList> routeListsToProceed,
			Car car,
			DateTime startDate,
			IndicatorsType indicatorsType,
			CancellationToken cancellationToken) 
		{
			var days = new string[daysInMonth];

			for(var dayId = 0; dayId < daysInMonth; dayId++)
			{
				var tripsCount = routeListsToProceed
					.Where(routeList => routeList.Car == car
										&& routeList.Date >= startDate.AddDays(dayId)
										&& routeList.Date < startDate.AddDays(dayId + 1)
										&& (indicatorsType == IndicatorsType.Plan
										|| routeList.Addresses.Any(routeListAddress => !_notActualRouteListAddressStatuses.Contains(routeListAddress.Status))))
					.Count();

				if(tripsCount > 0)
				{
					days[dayId] = tripsCount.ToString();
				}
			}

			return await new ValueTask<string[]>(days);
		}

		private async Task<IEnumerable<CarEvent>> GetCarEvents(
			IEnumerable<CarTypeOfUse> carTypesOfUse,
			Car car,
			AllYesNo raskat,
			DriverCarKind driverCarKind,
			DateTime startDate,
			DateTime endDate,
			CancellationToken cancellationToken
			)
		{
			return await Task.Run(() => UoW.Session.Query<CarEvent>()
				.Where(carEvent => carEvent.Car != null
									&& carEvent.Car.IsArchive == false
									&& carEvent.Car.TypeOfUse != CarTypeOfUse.CompanyTruck
									&& carTypesOfUse.Contains(carEvent.Car.TypeOfUse.Value)
									&& (carEvent.Car.Driver == null || !carEvent.Car.Driver.VisitingMaster)
									&& (car == null || carEvent.Car == car)
									&& (raskat == AllYesNo.All || carEvent.Car.IsRaskat == (raskat == AllYesNo.Yes))
									&& (driverCarKind == null
										|| (carEvent.Car.DriverCarKind != null
											&& carEvent.Car.DriverCarKind == driverCarKind))
									&& carEvent.StartDate <= endDate
									&& carEvent.EndDate >= startDate)
				.Fetch(carEvent => carEvent.CarEventType)
				.ToList(),
				cancellationToken);
		}

		private async Task<IEnumerable<RouteList>> GetRouteLists(
			IEnumerable<CarTypeOfUse> carTypesOfUse,
			Car car,
			AllYesNo raskat,
			DriverCarKind driverCarKind,
			DateTime startDate,
			DateTime endDate,
			CancellationToken cancellationToken)
		{
			return await Task.Run(() => UoW.Session.Query<RouteList>()
				.Where(routeList => routeList.Car != null
								 && routeList.Car.IsArchive == false
								 && routeList.Car.TypeOfUse != CarTypeOfUse.CompanyTruck
								 && carTypesOfUse.Contains(routeList.Car.TypeOfUse.Value)
								 && (routeList.Car.Driver == null || !routeList.Car.Driver.VisitingMaster)
								 && (car == null || routeList.Car == car)
								 && (raskat == AllYesNo.All || routeList.Car.IsRaskat == (raskat == AllYesNo.Yes))
								 && (driverCarKind == null || (routeList.Car.DriverCarKind != null && routeList.Car.DriverCarKind == driverCarKind))
								 && routeList.Date >= startDate && routeList.Date < endDate)
				.Fetch(routeList => routeList.Car)
				.ThenFetch(selectorCar => selectorCar.Driver)
				.Fetch(routeList => routeList.Driver)
				.FetchMany(routeList => routeList.Addresses)
				.OrderBy(routeList => routeList.Car.Id)
				.OrderBy(routeList => routeList.Id)
				.ToList(),
				cancellationToken);
		}

		private async Task<List<UndeliveredOrder>> GetUndeliveriesForOrders(IEnumerable<int> ordersIds, CancellationToken cancellationToken)
		{
			return await Task.Run(() => UoW.Session.Query<UndeliveredOrder>()
				.Where(undeliveredOrder => ordersIds.Contains(undeliveredOrder.OldOrder.Id)
										&& undeliveredOrder.GuiltyInUndelivery.Any(
											guiltyInUndelivery => guiltyInUndelivery.GuiltySide == GuiltyTypes.Driver
															   || guiltyInUndelivery.GuiltyDepartment.SubdivisionType == SubdivisionType.Logistic))
				.ToList(),
				cancellationToken);
		}

		private async Task TouchOrders(IEnumerable<int> ids, CancellationToken cancellationToken)
		{
			await Task.Run(() => UoW.Session.Query<Order>()
				.Where(order => ids.Contains(order.Id))
				.Fetch(order => order.DeliveryPoint)
				.Fetch(order => order.Client)
				.Fetch(order => order.Contract)
				.FetchMany(order => order.OrderItems)
				.ThenFetch(orderItem => orderItem.Nomenclature)
				.ToList(),
				cancellationToken);
		}

		public void ShowWarning(string message)
		{
			_interactiveService.ShowMessage(ImportanceLevel.Warning, message);
		}

		private string GetDriverFormatedName(Employee driver)
		{
			if(driver == null)
			{
				return "-";
			}

			return driver.ShortName;
		}

		private decimal Calculate19LValue(IEnumerable<RouteList> routeListsToProceed, IndicatorsType indicatorsType, int carMax19LBottles)
		{
			var routeListsToProceedCount = routeListsToProceed.Count();

			if(routeListsToProceedCount > 0)
			{
				return Math.Round(routeListsToProceed.SelectMany(routeList => routeList.Addresses)
													 .Where(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
																			 || (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed))
													 .Select(routeListAddress => routeListAddress.Order)
													 .SelectMany(order => order.OrderItems)
													 .Where(orderItem => orderItem.Nomenclature.IsWater19L)
													 .Sum(orderItem => indicatorsType == IndicatorsType.Plan ? orderItem.Count : (orderItem.ActualCount ?? 0))
													/ carMax19LBottles * 100 / routeListsToProceedCount, 2);
			}
			return 0;
		}

		private decimal CalculateKilogramsValue(IEnumerable<RouteList> routeListsToProceed, IndicatorsType indicatorsType, decimal carMaxWeight)
		{
			var routeListsToProceedCount = routeListsToProceed.Count();

			if(routeListsToProceedCount > 0)
			{
				return Math.Round(routeListsToProceed
							   .SelectMany(routeList => routeList.Addresses)
							   .Where(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
													   || (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed))
							   .Select(routeListAddress => routeListAddress.Order)
							   .Sum(order => order.OrderItems.Sum(orderItem => (indicatorsType == IndicatorsType.Plan ? orderItem.Count : (orderItem.ActualCount ?? 0)) * Convert.ToDecimal(orderItem.Nomenclature.Weight))
							   / carMaxWeight * 100 / routeListsToProceedCount), 2);
			}
			return 0;
		}

		private decimal CalculateVolumeValue(IEnumerable<RouteList> routeListsToProceed, IndicatorsType indicatorsType, decimal carMaxVolume)
		{
			var routeListsToProceedCount = routeListsToProceed.Count();

			if(routeListsToProceedCount > 0)
			{
				return Math.Round(routeListsToProceed
								.SelectMany(routeList => routeList.Addresses)
								.Where(routeListAddress => (indicatorsType == IndicatorsType.Plan && !routeListAddress.WasTransfered)
														|| (indicatorsType == IndicatorsType.Fact && routeListAddress.Status == RouteListItemStatus.Completed))
								.Select(routeListAddress => routeListAddress.Order)
								.Sum(order => order.OrderItems.Sum(
									orderItem => (indicatorsType == IndicatorsType.Plan ? orderItem.Count : (orderItem.ActualCount ?? 0)) * Convert.ToDecimal(orderItem.Nomenclature.Volume))
									/ carMaxVolume * 100 / routeListsToProceedCount), 2);
			}

			return 0;
		}

		public void OnButtonExportReportClicked(object sender, EventArgs args)
		{
			string outputFile = @"CarExploitationReport-" + StartDate.ToString("yyyy-MM-dd") + ".xlsx";

			ExportReport(outputFile);
		}

		public void ExportReport(string path)
		{
			var template = new XLTemplate(_templatePath);

			template.AddVariable(Report);
			template.Generate();

			template.SaveAs(path);
		}

		private CarOwnType? GetCarOwnType(CarTypeOfUse? carTypeOfUse)
		{
			CarOwnType? result = null;

			if(carTypeOfUse != null)
			{
				result = carTypeOfUse == CarTypeOfUse.DriverCar ? CarOwnType.Driver : CarOwnType.Company;
			}

			return result;
		}

		private CompanyCarType? GetCompanyCarType(CarTypeOfUse? carTypeOfUse)
		{
			CompanyCarType? result = null;

			if(carTypeOfUse != null && carTypeOfUse != CarTypeOfUse.DriverCar)
			{
				result = carTypeOfUse == CarTypeOfUse.CompanyLargus ? CompanyCarType.Largus : CompanyCarType.Gazelle;
			}

			return result;
		}

		private IEnumerable<CarTypeOfUse> GetCarTypesOfUse(CarOwnType carOwnType, CompanyCarType? companyCarType = null)
		{
			var result = new List<CarTypeOfUse>();

			if(carOwnType == CarOwnType.Driver)
			{
				result.Add(CarTypeOfUse.DriverCar);
			}
			else
			{
				switch(companyCarType)
				{
					case CompanyCarType.Largus:
						result.Add(CarTypeOfUse.CompanyLargus);
						break;
					case CompanyCarType.Gazelle:
						result.Add(CarTypeOfUse.CompanyGAZelle);
						break;
					case CompanyCarType.All:
						result.AddRange(new[] { CarTypeOfUse.CompanyLargus, CarTypeOfUse.CompanyGAZelle });
						break;
				}
			}

			return result;
		}

		public void ShowInfoWindow()
		{
			var info =
				"Условные обозначения отчёта: <b>К</b> - авто компании, <b>Н</b> - наёмный автомобиль, <b>Л</b> - Ларгус, <b>Г</b> - Газель.\n" +
				"Столбики: <b>П</b> - принадлежность. <b>Т</b> - тип (Для <b>Н</b>: Сокр. название вида наёмного авто). <b>№</b> - номер. Показатель. <b>1,2,3</b> - даты в месяце.\n" +
				"Выборка в отчёт идёт согласно фильтрам и доп. условиям:\n" +
				" - Не попадают архивные автомобили, фуры, а также автомобили, привязанные к выездным мастерам.\n" +
				"Пояснения к показателям:\n\n" +
				"Условные обозначения: <b>Факт</b> - фильтр по фактическим данным. <b>План</b> - фильтр по планируемым данным.\n\n" +

				$"<b>{Indicator.Trips.GetEnumTitle()}</b>: Сумма Кол-ва МЛ.\n" +
				$"Факт: не считает МЛ, у которых все адреса в статусах {RouteListItemStatus.Transfered.GetEnumTitle()}, {RouteListItemStatus.Overdue.GetEnumTitle()} и {RouteListItemStatus.Canceled.GetEnumTitle()}.\n\n" +

				$"<b>{Indicator.WageDistricts.GetEnumTitle()}</b>: Если за день есть хоть один адрес в Пригороде - П, иначе Г.\n" +
				$"Факт: не считаются адреса в статусах {RouteListItemStatus.Transfered.GetEnumTitle()}, {RouteListItemStatus.Overdue.GetEnumTitle()} и {RouteListItemStatus.Canceled.GetEnumTitle()}.\n" +
				"План: не считаются адреса, перенесённые в этот МЛ.\n\n" +

				$"<b>{Indicator.MileagePlan.GetEnumTitle()}</b>: Сумма планируемого расстояния по всем МЛ.\n" +
				"Не отображается для <b>Н</b>.\n" +
				"Факт: не отображается.\n\n" +

				$"<b>{Indicator.MileageRecalculated.GetEnumTitle()}</b>: Сумма пересчитанного расстояния по всем МЛ.\n" +
				"Не отображается для <b>Н</b>.\n" +
				"План: не отображается.\n\n" +

				$"<b>{Indicator.MileageConfirmed.GetEnumTitle()}</b>: Сумма подтверждённого расстояния по всем МЛ.\n" +
				"Не отображается для <b>Н</b>.\n" +
				"План: не отображается.\n\n" +

				$"<b>{Indicator.FuelOverspending.GetEnumTitle()}</b>: Разница подтверждённого и пересчитанного расстояний по всем МЛ.\n" +
				"Не отображается для <b>Н</b>.\n" +
				"План: не отображается.\n\n" +

				$"<b>{Indicator.Undeliveries.GetEnumTitle()}</b>: Сумма кол-ва отмен заказов по всем МЛ по вине Подразделений логистики и Водителей.\n" +
				"План: не отображается.\n\n" +

				$"<b>{Indicator.LateArrivals.GetEnumTitle()}</b>: Сумма кол-ва опозданий по всем адресам по всем МЛ.\n" +
				"План: не отображается.\n\n" +

				$"<b>{Indicator.Addresses.GetEnumTitle()}</b>: Сумма кол-ва адресов во всех МЛ.\n" +
				$"Факт: не считаются адреса в статусах {RouteListItemStatus.Transfered.GetEnumTitle()}, {RouteListItemStatus.Overdue.GetEnumTitle()} и {RouteListItemStatus.Canceled.GetEnumTitle()}.\n" +
				"План: не считаются адреса, перенесённые в этот МЛ.\n\n" +

				$"<b>{Indicator.Forwarders.GetEnumTitle()}</b>: Сумма кол-ва МЛ с экспедиторами.\n" +
				"Не отображается для <b>К Л</b>.\n" +
				$"Факт: Не считает МЛ, у которых все адреса в статусах {RouteListItemStatus.Transfered.GetEnumTitle()}, {RouteListItemStatus.Overdue.GetEnumTitle()} и {RouteListItemStatus.Canceled.GetEnumTitle()}.\n\n" +

				$"<b>{Indicator.Districts.GetEnumTitle()}</b>: Сумма кол-ва адресов во всех МЛ, не попадающих в районы, закрепленные за водителем в МЛ.\n" +
				"Версия приоритетов районов водителя подбирается аналогично версии графиков.\n" +
				$"Факт: не считаются адреса в статусах {RouteListItemStatus.Transfered.GetEnumTitle()}, {RouteListItemStatus.Overdue.GetEnumTitle()} и {RouteListItemStatus.Canceled.GetEnumTitle()}.\n" +
				"План: не считаются адреса, перенесённые в этот МЛ.\n\n" +

				$"<b>{Indicator.Loading19Litres.GetEnumTitle()}, {Indicator.LoadingKilograms.GetEnumTitle()}, {Indicator.LoadingCubicMeters.GetEnumTitle()}</b>: Сумма процентной загрузки авто по всем МЛ.\n" +
				"Факт: считаются только выполненные адреса.\n" +
				"План: не считаются адреса, перенесённые в этот МЛ.\n\n" +

				$"<b>{Indicator.LoadingAverage.GetEnumTitle()}</b>: Cреднее по 19л, кг, м3.";

			_interactiveService.ShowMessage(ImportanceLevel.Info, info, "Информация");
		}

		public void ShowCantSelectRaskatCarMessage()
		{
			_interactiveService.ShowMessage(ImportanceLevel.Warning, "Нельзя выбрать раскатный автомобиль компании в этот отчёт");
		}
	}

	public class CarsExploitationReport
	{
		public DateTime CreationDate { get; set; }
		public DateTime StartDate { get; set; }
		public IndicatorsType IndicatorsType { get; set; }
		public CarOwnType CarOwnType { get; set; }
		public CompanyCarType CompanyCarType { get; set; }
		public DriverCarKind DriverCarKind { get; set; }
		public AllYesNo Raskat { get; set; } = AllYesNo.No;
		public Car Car { get; set; }
		public IEnumerable<Indicator> SelectedIndicators { get; set; }
		public string SelectedIndicatorsString => string.Join(", ", SelectedIndicators.Select(x => x.GetEnumTitle()));
		public IEnumerable<CarsExploitationReportRow> Rows { get; set; }
	}

	public class CarsExploitationReportRow
	{
		public int CarOrderNumber { get; set; }
		public CarOwnType? CarOwnType { get; set; }
		public string CarOwnTypeName => CarOwnType != null ? CarOwnType.Value == Reports.CarOwnType.Company ? "К":"Н" : "";
		public CompanyCarType? CarType { get; set; }
		public string CarTypeName => CarType != null ? (CarType == CompanyCarType.Gazelle ? "Г" : "Л") : "";
		public string RegNumber { get; set; }
		public Indicator Indicator { get; set; }
		public string IndicatorName => Indicator.GetEnumTitle();
		public string AssignedDriver { get; set; }
		public string GeographicalGroups { get; set; }
		public string[] Days { get; set; }
	}

	public enum IndicatorsType
	{
		[Display(Name = "фактическим")]
		Fact,
		[Display(Name = "планируемым")]
		Plan
	}

	public enum CarOwnType
	{
		[Display(Name = "Автопарк компании")]
		Company,
		[Display(Name = "Наёмный транспорт")]
		Driver
	}

	public enum CompanyCarType
	{
		[Display(Name = "Все")]
		All,
		[Display(Name = "Ларгус")]
		Largus,
		[Display(Name = "Газель")]
		Gazelle
	}

	public enum Indicator
	{
		[Display(Name = "Рейсы")]
		Trips,
		[Display(Name = "События ТС")]
		CarEvents,
		[Display(Name = "Город/Пригород")]
		WageDistricts,
		[Display(Name = "Км предп")]
		MileagePlan,
		[Display(Name = "Км пересчит")]
		MileageRecalculated,
		[Display(Name = "Км подтв")]
		MileageConfirmed,
		[Display(Name = "Перерасход")]
		FuelOverspending,
		[Display(Name = "Недовозы")]
		Undeliveries,
		[Display(Name = "Опоздания")]
		LateArrivals,
		[Display(Name = "График")]
		WorkSchedules,
		[Display(Name = "Районы")]
		Districts,
		[Display(Name = "Адреса")]
		Addresses,
		[Display(Name = "Экспедиторы")]
		Forwarders,
		[Display(Name = "Загрузка")]
		LoadingAverage,
		[Display(Name = "19л")]
		Loading19Litres,
		[Display(Name = "кг")]
		LoadingKilograms,
		[Display(Name = "м3")]
		LoadingCubicMeters
	}
}
